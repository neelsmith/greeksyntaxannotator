### USER
I want to write a web app as a single HTML file using HTML, Javascript and CSS. The app will allow readers to annotate tokens in a Greek text. We'll develop it gradually. First I want to build a UI for loading and organizing the data the user will annotate. Begin by letting the user enter a URL for a citable corpus of texts. Use this as the default value:
`https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex`
To load a citable text corpus from a URL, I want to use the `cex.js` library. Please include it like this:
`<script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>`
Then we'll use its `loadFromUrl` function with one parameter, the user-selected URL. This will return a `Promise<CEXParser>`. When we have a parser instance, we'll use `getDelimitedData("ctsdata")` to find citable text data (CTS data) in that source. Here's an example from the library documentation of how that could work:
```
const parser = new CEXParser();
parser.loadFromUrl(url)
    .then(p => {
        console.log('CEX data loaded from URL!');
        console.log(p.getDelimitedData("ctsdata"));
    })
    .catch(error => console.error('Failed to load from URL:', error));
  
  
```
`getDelimitedData` will return a string with each line representing a citable passage of text. Please split this into an Array of strings with one entry for each line.
With the text corpus extracted, we can structure it for analysis using the `greeklib.js` library, available here:
`https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js`.
We'll first tokenize the corpus, using the array of strings as the only parameter to `greeklib.tokenize`. This will return an Array of `Token` objects. Each `Token` has four properties, `sequence` (an integer), and three string values named `urn`, `text` and `type`, which we'll use later.
We'll also get a list of sentence references for the corpus. Use the array of strings as the only parameter to `greeklib.sentences`. Create a menu of these references for the user to choose from.
When the user chooses one, find the tokens that belong to that sentence using the `greeklib.tokens` function with two parameters: the identifier the user has selected, and the array of `Token`s. This will return the array of `Token`s belonging to that sentence (a subset of the complete array of `Token`s).
Display the sentence tokens belonging as a continuous text formatted by considering the `type` property of each token. Tokens with of type `punctuation`are always followed by a space. Tokens of type `lexical` should be followed immediately by their `sequence` property formatted as superscript in silver color. This is followed by a space unless the next token is a punctuation. Make each lexical token clickable.
The annotating functionality will ultimately support 4 modes of annotation. The first mode must be completed before proceding to any of the others. Offer the user a check box to mark if the sentence illustrates _asyndeton_. If the user checks yes, mode 1 is complete. Otherwise, the user should be prompted to click on one node that is the _connecting word_. This word should be highlighted in the continuous display with a yellow background.
When the user has completed the first annotation, we'll proceed to mode 2.
In mode 2, the user will edit an intially empty table with three columns, representing _verbal units_. Column 1 should have the heading "Syntactic type"; column 2 should have the heading "Semantic type"; column 3 should be labelled "Depth". The user should be given an option to add a new row to the table. The user should then be able to choose a value for "Syntactic type" from a list with these values: "independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle". For column "Semantic type", the user should be able to choose from a list "transitive",
"intransitive", "linking". For "Depth", the user should be able to enter an integer value. When the user has entered values for all 3 columns, the user should be able to confirm and enter the values for that row. The user should be able to delete rows from the table.
Please implement this in an HTML page.

### ASSISTANT
Okay, this sounds like an interesting project! We'll build this single HTML file web app step by step.

Here's the HTML file with the initial UI for loading data, selecting sentences, displaying them, and implementing the first two annotation modes as requested.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-B">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow;
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px; /* Small separation from word */
        }
        .punctuation-token {
            /* No special styling needed for now, but class is there */
        }
        .hidden {
            display: none !important; /* Use important to override potential conflicts */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none; /* No borders within the form table */
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 1.8;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label>
            <input type="checkbox" id="asyndetonCheckbox">
            This sentence illustrates <em>asyndeton</em>.
        </label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr>
                    <td><label for="newVuSyntacticType">Syntactic Type:</label></td>
                    <td><select id="newVuSyntacticType"></select></td>
                </tr>
                <tr>
                    <td><label for="newVuSemanticType">Semantic Type:</label></td>
                    <td><select id="newVuSemanticType"></select></td>
                </tr>
                <tr>
                    <td><label for="newVuDepth">Depth:</label></td>
                    <td><input type="number" id="newVuDepth" min="0" value="0"></td>
                </tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>

        <table id="verbalUnitsTable">
            <thead>
                <tr>
                    <th>Syntactic type</th>
                    <th>Semantic type</th>
                    <th>Depth</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="verbalUnitsTableBody">
                <!-- Rows will be added here by JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        // Global variables
        let allTokens = [];
        let currentSentenceURN = null;
        let annotations = {}; // Stores annotations per sentence URN

        // UI Elements
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');

        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        // Initialize dropdowns for new verbal unit form
        SYNTACTIC_TYPES.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            newVuSyntacticTypeSelect.appendChild(option);
        });
        SEMANTIC_TYPES.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            newVuSemanticTypeSelect.appendChild(option);
        });

        // Event Listeners
        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            // Reset form fields
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });

        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });


        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null, // null, true, or false
                    connectingWordURN: null,
                    verbalUnits: []
                };
            }
            return annotations[currentSentenceURN];
        }

        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) {
                updateStatus('Please enter a CEX URL.', true);
                return;
            }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser(); // From cex.js
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        updateStatus('No "ctsdata" block found in the CEX file.', true);
                        return;
                    }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines); // From greeklib.js
                const sentenceURNs = greeklib.sentences(ctsLines); // From greeklib.js

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>'; // Clear previous
                sentenceURNs.forEach(urn => {
                    const option = document.createElement('option');
                    option.value = urn;
                    option.textContent = urn; // Or a more human-readable version if available
                    sentenceDropdown.appendChild(option);
                });

                sentenceSelectorDiv.classList.remove('hidden');
                sentenceDisplayAreaDiv.classList.add('hidden');
                annotationMode1Div.classList.add('hidden');
                annotationMode2Div.classList.add('hidden');
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            if (!currentSentenceURN) {
                sentenceDisplayAreaDiv.classList.add('hidden');
                annotationMode1Div.classList.add('hidden');
                annotationMode2Div.classList.add('hidden');
                sentenceDisplay.innerHTML = '';
                return;
            }

            const currentAnnotation = getCurrentSentenceAnnotation(); // Ensures it's initialized
            
            const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            displaySentenceTokens(sentenceTokens);
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            // Reset and setup Mode 1
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnnotation.asyndeton === true;
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens(tokensToDisplay) {
            sentenceDisplay.innerHTML = ''; // Clear previous sentence
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < tokensToDisplay.length; i++) {
                const token = tokensToDisplay[i];
                const tokenOuterSpan = document.createElement('span'); // For overall spacing control if needed

                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn);

                    if (currentAnn && token.urn === currentAnn.connectingWordURN) {
                        tokenTextSpan.classList.add('connecting-word-highlight');
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);

                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < tokensToDisplay.length) ? tokensToDisplay[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    // Other token types, if any (e.g. whitespace, if greeklib produces them)
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    // Decide on spacing for other types if necessary
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; // Asyndeton means no connecting word
                // Re-display sentence to remove potential highlight
                const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
                displaySentenceTokens(sentenceTokens);
            }
            updateMode1StateAndProceed();
        }

        function handleLexicalTokenClick(urn) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || ann.asyndeton === true) { // Only if not asyndeton and mode 1 active
                return; 
            }

            // Check if mode 1 is still pending (not yet complete)
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);
            if (mode1Completed && ann.connectingWordURN !== urn) {
                 // If mode 1 was complete with a different word, and user clicks another,
                 // we are essentially "re-doing" this part of mode 1.
                 // Or, if user unchecks asyndeton and then clicks a word.
            } else if (mode1Completed && ann.connectingWordURN === urn) {
                // Clicking the same word again does nothing new for mode 1 completion.
                return;
            }


            ann.connectingWordURN = urn;
            ann.asyndeton = false; // Explicitly set asyndeton to false if a connecting word is chosen
            asyndetonCheckbox.checked = false;

            // Re-display sentence to apply/update highlight
            const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            displaySentenceTokens(sentenceTokens);
            
            updateMode1StateAndProceed();
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode1Div.classList.add('hidden');
                annotationMode2Div.classList.add('hidden');
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = false;

            if (ann.asyndeton === true) {
                mode1Completed = true;
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Completed = true;
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
            } else { // asyndeton is null or false, and no connecting word
                ann.asyndeton = false; // Default to not asyndeton if not explicitly set
                asyndetonCheckbox.checked = false;
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Please complete the selection above.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                annotationMode2Div.classList.add('hidden'); // Hide mode 2 if mode 1 not complete
                // Clear Mode 2 form/table if it was visible
                newVerbalUnitForm.classList.add('hidden');
                addVerbalUnitBtn.classList.remove('hidden');
                verbalUnitsTableBody.innerHTML = '';
            }
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden'); // Hide form initially
            addVerbalUnitBtn.classList.remove('hidden'); // Show add button
            renderVerbalUnitsTable();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; // Clear existing rows

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) {
                alert("Depth must be a non-negative integer.");
                return;
            }

            ann.verbalUnits.push({ syntacticType, semanticType, depth });
            renderVerbalUnitsTable();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            ann.verbalUnits.splice(index, 1);
            renderVerbalUnitsTable();
        }

    </script>
</body>
</html>
```

### USER
  
  
Great! Once the user confirmed one row, mode 2 remains available to add new rows, but mode 3 now becomes available. The table edited in mode represents _verbal units_. In mode three, the user will assign tokens to one of the defined  verbal units. The user should be able to select from a list of the verbal units, then begin clicking on tokens in the display. This should assign the token to the selected verbal unit. Clicking should function as a toggle: if the token is already assigned to the selected verbal unit, clicking should remove it from the list. Each verbal unit should be assigned a random color with 50%
  
Once the user has assigned more than one token to a verbal unit, mode 4 becomes available as well. In mode 4, the user edits a table defining relations among tokens in a verbal unit. The table should have 6 columns: labelled "Reference", "Token", "Node 1", "Node 1 relation", "Node 2" and "Node 2 relation". The table should be initialzed with one row for each lexical token in the passage, using the string value of the token as the value for the "Token" column, and the ID number as the value for the "Reference" column. These columns are not editable. The columns "Node 1" and "Node 2" are initially null, user-editable integer values. The user may enter the reference number for another token. User-entered values must refer to an integer value appearing in the table's reference column.
  
Above the table editor, the page should include a Mermaid visualization of a top-down directed graph. Use the 3 columns with integer values as the IDs for relations among nodes; use the "Token" column as the label for the node identified by the "Reference" column. Use "Node 1 relation" as the label for edge between "Reference" and "Node 1"; use "Node 2 relation" as the label for edge between "Reference" and "Node 2".  Do not include unlinked nodes in the graph. **Example***: if a table included three rows like this:
  
  
| Reference | Token | Node 1 | Node 1 relation | Node 2 | Node 2 relation |
| --- | --- | ---  | --- | --- | --- |
| 12 |  ἡ | 14 | article | ||
| 13 |  αὐτὴ |  |  | ||
| 14 | τιμωρία |  |  | ||
  
  
THe Mermaid graph would look like:
  
  
```mermaid
graph BT
12[" ἡ"]-- article --> 14["τιμωρία"]
```
  
  
Please implement this.

### ASSISTANT
Okay, this is a significant extension! We'll integrate Mode 3 for assigning tokens to verbal units and Mode 4 for defining relationships between tokens within a verbal unit, including the Mermaid graph visualization.

Here's the updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; /* For background visibility */
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow;
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #verbalUnitRelationsTable input[type="number"] {
            width: 60px;
        }
        #verbalUnitRelationsTable input[type="text"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2>Annotation Mode 4: Token Relations within Verbal Unit</h2>
        <p>Define relations for tokens in the verbal unit: <strong id="currentVuForRelationsLabel"></strong></p>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="verbalUnitRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="verbalUnitRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = [];
        let currentSentenceURN = null;
        let annotations = {}; // Stores annotations per sentence URN
        let currentSelectedVerbalUnitIndex = -1; // Index in annotations[...].verbalUnits
        let tokenMapForCurrentSentence = {}; // For quick lookup of token by sequence

        // UI Elements
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');

        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');

        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');

        const annotationMode4Div = document.getElementById('annotationMode4');
        const currentVuForRelationsLabel = document.getElementById('currentVuForRelationsLabel');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const verbalUnitRelationsTableBody = document.getElementById('verbalUnitRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        // Event Listeners
        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: []
                };
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200); // Avoid too light colors
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`; // 50% opacity
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) {
                updateStatus('Please enter a CEX URL.', true); return;
            }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        updateStatus('No "ctsdata" block found in the CEX file.', true); return;
                    }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; // Reset selected VU

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                return;
            }

            getCurrentSentenceAnnotation(); // Ensure it's initialized
            const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            // Build tokenMapForCurrentSentence for quick lookups by sequence
            tokenMapForCurrentSentence = {};
            sentenceTokens.forEach(token => {
                if(token.type === 'lexical') tokenMapForCurrentSentence[token.sequence] = token;
            });

            displaySentenceTokens(sentenceTokens);
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = annotations[currentSentenceURN].asyndeton === true;
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens(tokensToDisplay) {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();
            const selectedVU = (currentAnn && currentSelectedVerbalUnitIndex !== -1) ? currentAnn.verbalUnits[currentSelectedVerbalUnitIndex] : null;

            for (let i = 0; i < tokensToDisplay.length; i++) {
                const token = tokensToDisplay[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; // Store sequence for easier access
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    if (currentAnn && token.urn === currentAnn.connectingWordURN) {
                        tokenTextSpan.classList.add('connecting-word-highlight');
                    }
                    if (selectedVU && selectedVU.assignedTokenURNs.includes(token.urn)) {
                        tokenTextSpan.style.backgroundColor = selectedVU.color;
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < tokensToDisplay.length) ? tokensToDisplay[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null;
                const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
                displaySentenceTokens(sentenceTokens); // Re-render to remove highlight
            }
            updateMode1StateAndProceed();
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            // Mode 1: Connecting Word selection
            if (!annotationMode1Div.classList.contains('hidden') && !ann.asyndeton && 
                !(ann.asyndeton === false && ann.connectingWordURN)) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false;
                asyndetonCheckbox.checked = false;
                const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
                displaySentenceTokens(sentenceTokens); // Re-render to apply/update highlight
                updateMode1StateAndProceed();
                return; // Stop further processing if it was for Mode 1
            }

            // Mode 3: Token assignment to selected Verbal Unit
            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { // Token is already in this VU, remove it
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                    // Also remove its entry from relations if it exists
                    if (selectedVU.relations[sequence]) {
                        delete selectedVU.relations[sequence];
                        // Need to check if this token was a target for other tokens and clear those too
                        for (const refSeq in selectedVU.relations) {
                            if (selectedVU.relations[refSeq].node1Sequence === sequence) {
                                selectedVU.relations[refSeq].node1Sequence = null;
                                selectedVU.relations[refSeq].node1Rel = null;
                            }
                            if (selectedVU.relations[refSeq].node2Sequence === sequence) {
                                selectedVU.relations[refSeq].node2Sequence = null;
                                selectedVU.relations[refSeq].node2Rel = null;
                            }
                        }
                    }
                } else { // Token not in this VU, add it
                    selectedVU.assignedTokenURNs.push(urn);
                    // Initialize its entry in relations
                    if (!selectedVU.relations[sequence]) {
                         const tokenObj = allTokens.find(t => t.urn === urn);
                         if (tokenObj) {
                            selectedVU.relations[sequence] = { 
                                tokenText: tokenObj.text, 
                                node1Sequence: null, node1Rel: null, 
                                node2Sequence: null, node2Rel: null 
                            };
                         }
                    }
                }
                renderVerbalUnitsTable(); // Update token count display
                const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
                displaySentenceTokens(sentenceTokens); // Re-render for VU color
                checkAndEnableMode4();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
            } else {
                ann.asyndeton = false; // Default
                asyndetonCheckbox.checked = false;
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); // Check if Mode 3 can be enabled
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length; // Display token count
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) {
                alert("Depth must be a non-negative integer."); return;
            }
            
            // Add new verbal unit with initial empty assignments and relations
            ann.verbalUnits.push({ 
                id: Date.now(), // Simple unique ID
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [],
                relations: {} // Initialize as object: { sequence: { tokenText, node1Seq, node1Rel, ...}}
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); // Update Mode 3 based on new VU

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.verbalUnits.splice(index, 1);
            
            // If the deleted VU was selected for assignment, reset selection
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1;
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; // Adjust index if an earlier item was removed
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); // Re-evaluate Mode 3 and 4
            const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens); // Re-render sentence to remove highlights if any
            displaySentenceTokens(sentenceTokens);
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                // Automatically select first VU if none is selected, or maintain current if valid
                if (currentSelectedVerbalUnitIndex === -1 && ann.verbalUnits.length > 0) {
                    currentSelectedVerbalUnitIndex = 0;
                }
                if (currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) { // current selection invalid
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;

                const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens); // Re-render sentence for potential new highlights
                displaySentenceTokens(sentenceTokens);
                checkAndEnableMode4(); // Check if Mode 4 can be enabled for the (newly) selected VU
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1; // No VUs, so no selection
                checkAndEnableMode4(); // This will hide Mode 4
            }
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            // Restore selection if possible
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < ann.verbalUnits.length) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0"; // Default to first if selection lost
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
            const sentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            displaySentenceTokens(sentenceTokens); // Re-render sentence with highlights for the new VU
            checkAndEnableMode4(); // Check Mode 4 based on new VU selection
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (currentSelectedVerbalUnitIndex !== -1 && ann && ann.verbalUnits[currentSelectedVerbalUnitIndex]) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                if (selectedVU.assignedTokenURNs.length > 1) {
                    annotationMode4Div.classList.remove('hidden');
                    currentVuForRelationsLabel.textContent = `VU ${currentSelectedVerbalUnitIndex + 1}: ${selectedVU.syntacticType}`;
                    populateRelationsTable(selectedVU);
                    renderMermaidGraph(selectedVU);
                    mode4Status.textContent = "";
                } else {
                    annotationMode4Div.classList.add('hidden');
                    mode4Status.textContent = "Mode 4 requires at least 2 tokens assigned to the selected verbal unit.";
                    mermaidDiv.innerHTML = ""; // Clear graph
                }
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "";
                 mermaidDiv.innerHTML = ""; // Clear graph
            }
        }

        function populateRelationsTable(verbalUnit) {
            verbalUnitRelationsTableBody.innerHTML = '';
            const assignedLexicalTokens = verbalUnit.assignedTokenURNs
                .map(urn => allTokens.find(t => t.urn === urn))
                .filter(token => token && token.type === 'lexical')
                .sort((a,b) => a.sequence - b.sequence); // Sort by sequence for consistent order

            const validTokenSequencesInVU = new Set(assignedLexicalTokens.map(t => t.sequence));

            assignedLexicalTokens.forEach(token => {
                const refSeq = token.sequence;
                const tokenText = token.text;

                // Ensure relation entry exists
                if (!verbalUnit.relations[refSeq]) {
                    verbalUnit.relations[refSeq] = { tokenText: tokenText, node1Sequence: null, node1Rel: null, node2Sequence: null, node2Rel: null };
                }
                const relationData = verbalUnit.relations[refSeq];
                // Update tokenText in case it was stale (though unlikely if URNs are primary key)
                relationData.tokenText = tokenText; 


                const row = verbalUnitRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = tokenText;

                // Node 1 Sequence
                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = relationData.node1Sequence !== null ? relationData.node1Sequence : '';
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                    if (val !== null && !validTokenSequencesInVU.has(val)) {
                        alert(`Invalid Node 1 ID: ${val}. Must be a reference of a token in this verbal unit.`);
                        e.target.value = relationData.node1Sequence !== null ? relationData.node1Sequence : ''; // Revert
                        return;
                    }
                    relationData.node1Sequence = val;
                    if(val === null) relationData.node1Rel = null; // Clear relation if node cleared
                    renderMermaidGraph(verbalUnit);
                    populateRelationsTable(verbalUnit); // Refresh table to reflect potential clearing of rel
                };
                node1Cell.appendChild(node1Input);

                // Node 1 Relation
                const node1RelCell = row.insertCell();
                const node1RelInput = document.createElement('input');
                node1RelInput.type = 'text';
                node1RelInput.value = relationData.node1Rel || '';
                node1RelInput.onchange = (e) => {
                    relationData.node1Rel = e.target.value.trim() || null;
                    renderMermaidGraph(verbalUnit);
                };
                node1RelCell.appendChild(node1RelInput);

                // Node 2 Sequence
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = relationData.node2Sequence !== null ? relationData.node2Sequence : '';
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                     if (val !== null && !validTokenSequencesInVU.has(val)) {
                        alert(`Invalid Node 2 ID: ${val}. Must be a reference of a token in this verbal unit.`);
                        e.target.value = relationData.node2Sequence !== null ? relationData.node2Sequence : ''; // Revert
                        return;
                    }
                    relationData.node2Sequence = val;
                    if(val === null) relationData.node2Rel = null; // Clear relation if node cleared
                    renderMermaidGraph(verbalUnit);
                    populateRelationsTable(verbalUnit); // Refresh table
                };
                node2Cell.appendChild(node2Input);

                // Node 2 Relation
                const node2RelCell = row.insertCell();
                const node2RelInput = document.createElement('input');
                node2RelInput.type = 'text';
                node2RelInput.value = relationData.node2Rel || '';
                node2RelInput.onchange = (e) => {
                    relationData.node2Rel = e.target.value.trim() || null;
                    renderMermaidGraph(verbalUnit);
                };
                node2RelCell.appendChild(node2RelInput);
            });
        }
        
        async function renderMermaidGraph(verbalUnit) {
            let mermaidString = 'graph BT\n'; // Bottom to Top as per example
            const nodesInGraph = new Set();
            const edges = [];

            const assignedLexicalTokensMap = {};
            verbalUnit.assignedTokenURNs
                .map(urn => allTokens.find(t => t.urn === urn))
                .filter(token => token && token.type === 'lexical')
                .forEach(token => assignedLexicalTokensMap[token.sequence] = token.text);

            for (const refSeqStr in verbalUnit.relations) {
                const refSeq = parseInt(refSeqStr, 10);
                const relation = verbalUnit.relations[refSeq];
                const refTokenText = assignedLexicalTokensMap[refSeq] || `Seq ${refSeq}`;

                if (relation.node1Sequence !== null && relation.node1Rel) {
                    const node1Text = assignedLexicalTokensMap[relation.node1Sequence] || `Seq ${relation.node1Sequence}`;
                    edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relation.node1Rel)}" --> ${relation.node1Sequence}["${escapeMermaidLabel(node1Text)}"]`);
                    nodesInGraph.add(refSeq);
                    nodesInGraph.add(relation.node1Sequence);
                }
                if (relation.node2Sequence !== null && relation.node2Rel) {
                    const node2Text = assignedLexicalTokensMap[relation.node2Sequence] || `Seq ${relation.node2Sequence}`;
                    edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relation.node2Rel)}" --> ${relation.node2Sequence}["${escapeMermaidLabel(node2Text)}"]`);
                    nodesInGraph.add(refSeq);
                    nodesInGraph.add(relation.node2Sequence);
                }
            }
            
            // Declare nodes that are part of edges but might not be sources
            // (Mermaid usually handles this implicitly if IDs are just numbers)
            // Or explicitly:
            // nodesInGraph.forEach(seq => {
            //    const text = assignedLexicalTokensMap[seq] || `Seq ${seq}`;
            //    mermaidString += `    ${seq}["${escapeMermaidLabel(text)}"]\n`;
            // });
            // For the "Do not include unlinked nodes" requirement, simply adding edges is enough.
            // If there are no edges, the graph will be empty (or just "graph BT").

            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined for this verbal unit.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                // Ensure the div is clean for Mermaid to process
                mermaidDiv.innerHTML = ''; 
                // mermaid.render wants an ID for the new SVG, not the container div itself
                const { svg, bindFunctions } = await mermaid.render('graphSvg', mermaidString);
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) {
                    bindFunctions(mermaidDiv); // Binds events if any
                }
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            // Basic escape for quotes. Mermaid labels can be tricky.
            // For "text in quotes", Mermaid expects the internal quotes to be #quot; or similar HTML entity.
            // Or use backticks for labels if more complex characters are involved.
            // For now, simple quote escaping.
            return text.replace(/"/g, '#quot;');
        }

    </script>
</body>
</html>
```

### USER
Fantastic! The functionality is perfect! Let's make 1 tweak. In mode 4, let's include all assigned tokens in the list, from all verbal units, and include any token identified as the connecting token (in mode 1).

### ASSISTANT
Okay, that's a significant and good refinement for Mode 4, making it a more global relationship editor for the sentence's key tokens.

Here's the updated HTML file incorporating these changes. The core ideas are:
1.  Relations are now stored globally for the sentence in `annotations[currentSentenceURN].tokenRelations`.
2.  Mode 4 lists all tokens assigned to *any* verbal unit, plus the connecting word (if any).
3.  The Mermaid graph and relations table operate on this consolidated list of tokens.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow;
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable input[type="text"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; // All tokens from the CEX file
        let currentSentenceTokens = []; // Tokens of the currently selected sentence
        let currentSentenceURN = null;
        let annotations = {}; // Stores annotations per sentence URN
        let currentSelectedVerbalUnitIndex = -1; // Index in annotations[...].verbalUnits for Mode 3 assignment

        // UI Elements
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');

        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');

        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');

        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        // Event Listeners
        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} // Global relations for tokens in this sentence
                };
            }
            // Ensure tokenRelations exists if annotations object was created before this field
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); // Ensures it's initialized, including tokenRelations
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens();
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { // Ensure connecting word from previous session is in tokenRelations
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();
            const selectedVUForHighlight = (currentAnn && currentSelectedVerbalUnitIndex !== -1) ? currentAnn.verbalUnits[currentSelectedVerbalUnitIndex] : null;

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    if (currentAnn && token.urn === currentAnn.connectingWordURN) {
                        tokenTextSpan.classList.add('connecting-word-highlight');
                    }
                    
                    // Check if this token is in the currently selected VU for Mode 3 highlighting
                    if (selectedVUForHighlight && selectedVUForHighlight.assignedTokenURNs.includes(token.urn)) {
                        tokenTextSpan.style.backgroundColor = selectedVUForHighlight.color;
                    } else {
                        tokenTextSpan.style.backgroundColor = 'transparent'; // Reset if not in selected VU
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; // No connecting word if asyndeton
            }
            displaySentenceTokens(); // Re-render to update highlights
            updateMode1StateAndProceed();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                // Ensure tokenText is current
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; // Should not happen if clicked on lexical

            // Mode 1: Connecting Word selection
            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false; // Mode 1 not active UI-wise


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false;
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            // Mode 3: Token assignment to selected Verbal Unit
            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { // Token is in this VU, remove it
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { // Token not in this VU, add it
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); // Check if Mode 4 can be enabled/updated
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                // Ensure connecting word is in tokenRelations
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { // (asyndeton is null or false) AND no connecting word
                asyndetonCheckbox.checked = false; // Ensure it's unchecked if state is indeterminate
                ann.asyndeton = false; // Default to this path
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); // Always check mode 4 as connecting word affects it.
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; // Reset if the deleted one was selected
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); // Update highlights
            checkAndEnableMode4(); // Re-evaluate Mode 4 list
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;

                displaySentenceTokens();
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
                displaySentenceTokens(); // Clear any VU-specific highlights
            }
            checkAndEnableMode4(); // Mode 4 visibility can change
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
            displaySentenceTokens(); 
            // Mode 4 is independent of selected VU, but token display changes.
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; // Store {sequence, text, urn}
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            // Add connecting word
            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    if (!includedSequences.has(cwToken.sequence)) {
                        relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                        includedSequences.add(cwToken.sequence);
                        ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                    }
                }
            }

            // Add tokens from all verbal units
            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token) {
                             if (!includedSequences.has(token.sequence)) {
                                relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                                includedSequences.add(token.sequence);
                                ensureTokenRelationEntry(ann, token.sequence, token.text);
                            }
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => a.sequence - b.sequence);
            return relevantTokensData;
        }


        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);

            if (relevantTokens.length > 1) {
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens (from any Verbal Unit or as Connecting Word).";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                // Ensure entry in globalRelations (getMode4RelevantTokens should have done this)
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; // Use text from relevantTokens for consistency

                const createInput = (type, value, onChangeCallback) => {
                    const input = document.createElement('input');
                    input.type = type;
                    input.value = value !== null && value !== undefined ? value : '';
                    input.onchange = onChangeCallback;
                    return input;
                };
                
                const createNumberInput = (currentValue, key, relationData) => {
                    return createInput('number', currentValue, (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token listed in this table.`);
                            e.target.value = relationData[key] !== null ? relationData[key] : ''; // Revert
                            return;
                        }
                        relationData[key] = val;
                        if (val === null) { // If node is cleared, clear its relation text
                            if (key === 'node1Sequence') relationData.node1Rel = null;
                            if (key === 'node2Sequence') relationData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); // Refresh table
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                const createTextInput = (currentValue, key, relationData) => {
                     return createInput('text', currentValue, (e) => {
                        relationData[key] = e.target.value.trim() || null;
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; // Only process tokens currently relevant for Mode 4

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); // Unique ID for SVG
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); // Escape double quotes and semicolons
        }

    </script>
</body>
</html>
```

### USER
Perfect except for one detail. The display of sentence tokens is only highlighting the current verbal unit: it should maintain highlighting on all of them, and on the connecting word if any. Could you fix this?

### ASSISTANT
You're right, that's an important detail for visual clarity! The highlights should be persistent across modes once set.

We'll adjust the `displaySentenceTokens` function to ensure that:
1.  The connecting word (if any) is always highlighted yellow.
2.  Any token assigned to *any* verbal unit gets the background color of the *first* verbal unit it's found in (since a token is currently assigned to at most one VU via the UI, this is straightforward).
3.  If a token is both the connecting word and assigned to a verbal unit, the verbal unit's semi-transparent color will overlay the yellow, so both aspects are visible.

Here's the modified part of the JavaScript within the HTML file. Only the `displaySentenceTokens` function needs this adjustment.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow;
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable input[type="text"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); // This will now apply all relevant highlights
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    // Reset background style and connecting word class for this token
                    tokenTextSpan.style.backgroundColor = 'transparent';
                    tokenTextSpan.classList.remove('connecting-word-highlight');

                    if (currentAnn) {
                        // Apply connecting word highlight if applicable
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight');
                        }

                        // Apply verbal unit highlight if applicable
                        // A token will take the color of the *first* verbal unit it's found in.
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundColor = vu.color; // vu.color is rgba with 0.5 opacity
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false;
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); // Refresh highlights regardless of Mode 3 visibility
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
            // No need to call displaySentenceTokens here, as Mode 3 selection doesn't change the *overall* highlighting
            // which is now handled by displaySentenceTokens showing all VU assignments.
            // However, if we wanted the *selected* VU to have a special border or something, this is where it would go.
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    if (!includedSequences.has(cwToken.sequence)) {
                        relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                        includedSequences.add(cwToken.sequence);
                        ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                    }
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token) {
                             if (!includedSequences.has(token.sequence)) {
                                relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                                includedSequences.add(token.sequence);
                                ensureTokenRelationEntry(ann, token.sequence, token.text);
                            }
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => a.sequence - b.sequence);
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);

            if (relevantTokens.length > 1) {
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens (from any Verbal Unit or as Connecting Word).";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createInput = (type, value, onChangeCallback) => {
                    const input = document.createElement('input');
                    input.type = type;
                    input.value = value !== null && value !== undefined ? value : '';
                    input.onchange = onChangeCallback;
                    return input;
                };
                
                const createNumberInput = (currentValue, key, relationData) => {
                    return createInput('number', currentValue, (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token listed in this table.`);
                            e.target.value = relationData[key] !== null ? relationData[key] : ''; 
                            return;
                        }
                        relationData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relationData.node1Rel = null;
                            if (key === 'node2Sequence') relationData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                const createTextInput = (currentValue, key, relationData) => {
                     return createInput('text', currentValue, (e) => {
                        relationData[key] = e.target.value.trim() || null;
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Excellent: highlighting is persisting on tokens assigned to verbal units! We're still missing highlighting on a connecting word if one has been assigned. Could you fix that?

### ASSISTANT
You are absolutely right! My apologies, I missed that nuance in the interaction between the class-based yellow highlight and the style-based verbal unit color. If a `background-color` is set via `style`, it will indeed override a `background-color` set by a class.

To achieve the desired layering (semi-transparent verbal unit color *on top of* the solid yellow connecting word highlight), we can use the `background-image` property for the verbal unit color, as it layers on top of `background-color`.

Here's the corrected `displaySentenceTokens` function. The rest of the HTML and JavaScript remains the same.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; /* This will be the base color */
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable input[type="text"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    // Reset highlights for this token before re-applying
                    tokenTextSpan.classList.remove('connecting-word-highlight'); // Removes explicit yellow background-color
                    tokenTextSpan.style.backgroundImage = 'none'; // Clear potential VU highlight layer
                    tokenTextSpan.style.backgroundColor = 'transparent'; // Ensure base is transparent if no class

                    if (currentAnn) {
                        // Apply connecting word highlight if applicable (sets background-color: yellow via class)
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight');
                        }

                        // Apply verbal unit highlight if applicable (sets backgroundImage)
                        // A token will take the color of the *first* verbal unit it's found in.
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    // vu.color is like 'rgba(r,g,b,0.5)'
                                    // Using backgroundImage for the VU color will layer it over backgroundColor.
                                    // If .connecting-word-highlight is also present, its yellow will be the backgroundColor.
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; // Default, but good to be explicit
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false;
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    if (!includedSequences.has(cwToken.sequence)) {
                        relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                        includedSequences.add(cwToken.sequence);
                        ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                    }
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token) {
                             if (!includedSequences.has(token.sequence)) {
                                relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                                includedSequences.add(token.sequence);
                                ensureTokenRelationEntry(ann, token.sequence, token.text);
                            }
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => a.sequence - b.sequence);
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);

            if (relevantTokens.length > 1) {
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens (from any Verbal Unit or as Connecting Word).";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createInput = (type, value, onChangeCallback) => {
                    const input = document.createElement('input');
                    input.type = type;
                    input.value = value !== null && value !== undefined ? value : '';
                    input.onchange = onChangeCallback;
                    return input;
                };
                
                const createNumberInput = (currentValue, key, relationData) => {
                    return createInput('number', currentValue, (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token listed in this table.`);
                            e.target.value = relationData[key] !== null ? relationData[key] : ''; 
                            return;
                        }
                        relationData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relationData.node1Rel = null;
                            if (key === 'node2Sequence') relationData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                const createTextInput = (currentValue, key, relationData) => {
                     return createInput('text', currentValue, (e) => {
                        relationData[key] = e.target.value.trim() || null;
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Still no yellow highlighting appearing on the identified connecting word. Please review and fix.

### ASSISTANT
You are absolutely correct! My apologies for that persistent oversight. The issue was indeed with how the `background-color` (from the class for the connecting word) and the `background-image` (from the inline style for the verbal unit) were interacting, specifically because of an explicit `tokenTextSpan.style.backgroundColor = 'transparent';` I had in the reset logic.

Inline styles have higher specificity. So, `style="background-color: transparent;"` would override the `background-color: yellow;` from the `.connecting-word-highlight` class. Then, the `background-image` for the verbal unit would layer on top of this enforced transparent background, effectively hiding the yellow.

The fix is to remove the explicit setting of `backgroundColor` to `transparent` during the reset. The absence of the class and the `backgroundImage` will naturally result in a transparent background for the span.

Here's the corrected `displaySentenceTokens` function. The rest of the HTML and JavaScript remains the same.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; /* This will be the base color */
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable input[type="text"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];

        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    // Reset highlights: remove class and inline background image
                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';
                    // DO NOT set tokenTextSpan.style.backgroundColor = 'transparent' here,
                    // as that would override the class's background-color.

                    if (currentAnn) {
                        // Apply connecting word highlight if applicable
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); // Sets background-color: yellow via class
                        }

                        // Apply verbal unit highlight if applicable
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    // backgroundImage layers on top of current background-color (yellow from class or transparent default)
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false;
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    if (!includedSequences.has(cwToken.sequence)) {
                        relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                        includedSequences.add(cwToken.sequence);
                        ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                    }
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token) {
                             if (!includedSequences.has(token.sequence)) {
                                relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                                includedSequences.add(token.sequence);
                                ensureTokenRelationEntry(ann, token.sequence, token.text);
                            }
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => a.sequence - b.sequence);
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);

            if (relevantTokens.length > 1) {
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens (from any Verbal Unit or as Connecting Word).";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createInput = (type, value, onChangeCallback) => {
                    const input = document.createElement('input');
                    input.type = type;
                    input.value = value !== null && value !== undefined ? value : '';
                    input.onchange = onChangeCallback;
                    return input;
                };
                
                const createNumberInput = (currentValue, key, relationData) => {
                    return createInput('number', currentValue, (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token listed in this table.`);
                            e.target.value = relationData[key] !== null ? relationData[key] : ''; 
                            return;
                        }
                        relationData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relationData.node1Rel = null;
                            if (key === 'node2Sequence') relationData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                const createTextInput = (currentValue, key, relationData) => {
                     return createInput('text', currentValue, (e) => {
                        relationData[key] = e.target.value.trim() || null;
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    });
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createTextInput(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Great! Now a new tweak. In editing the table of token relations, let's allow the user to choose from a popup list of values for each of the two relation columns "Node 1 Relation" and "Node 2 Relation".  The values for the relations should be the following:
  
```
conjunction
subordinate conjunction
relative pronoun
unit verb
predicate
subject
direct object
object of preposition
direct address
complementary infinitive
supplementary participle
modal particle
adverbial
attributive
article
pronoun
dative
genitive
```
  
Could you add this?

### ASSISTANT
Okay, that's a good improvement for consistency and ease of use in Mode 4. We'll replace the free-text inputs for relation types with dropdowns populated by your specified list.

Here's the updated HTML with the necessary JavaScript changes, primarily in the `populateTokenRelationsTable` function and by adding a new constant for the relation values.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; /* Give selects some base width */
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { /* Style for the new relation selects */
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            ann.asyndeton = asyndetonCheckbox.checked;
            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false;
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    if (!includedSequences.has(cwToken.sequence)) {
                        relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                        includedSequences.add(cwToken.sequence);
                        ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                    }
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token) {
                             if (!includedSequences.has(token.sequence)) {
                                relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                                includedSequences.add(token.sequence);
                                ensureTokenRelationEntry(ann, token.sequence, token.text);
                            }
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => a.sequence - b.sequence);
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);

            if (relevantTokens.length > 1) {
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens (from any Verbal Unit or as Connecting Word).";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                // Helper for number input
                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                // Helper for relation select dropdown
                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; // Represents null
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; // Set current value, default to "" if null/undefined
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; // Store "" as null
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Lovely! One further tweak. If the sentence illustrates _asyndeton_ (no connecting word), could you add to the table of token relations in Mode 4 a row to represent that? It should have reference number `0`, and token value `asyndeton`.

### ASSISTANT
Okay, this is a very neat idea to integrate the asyndeton concept directly into the relational graph!

Here's how we can implement this:

1.  Define a constant for the asyndeton node's reference ID (e.g., `0`) and its text.
2.  Modify `getMode4RelevantTokens` to add this special "asyndeton" entry to `relevantTokensData` if `ann.asyndeton` is `true`. We'll also need to ensure it has an entry in `ann.tokenRelations`.
3.  Adjust `populateTokenRelationsTable` to correctly handle this node, particularly in validating target node IDs.
4.  Update `handleAsyndetonChange`: When asyndeton is unchecked, we should clean up any relations pointing to/from this special asyndeton node and remove its entry from `tokenRelations`.
5.  The Mermaid graph rendering should naturally incorporate it if it's part of the relations.

Here's the updated HTML with the JavaScript modifications:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                // Ensure the asyndeton node exists in relations for Mode 4
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                // Asyndeton is being turned OFF
                if (wasAsyndeton) { // Only clean up if it *was* asyndeton
                    // Remove the asyndeton node itself from relations
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    // Clean up any links pointing to the asyndeton node
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); // This will also call checkAndEnableMode4
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                // Ensure tokenText is current, especially for the asyndeton node
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; // Ensure asyndeton is off if connecting word is clicked
                // If asyndeton was previously true, clean up its relations
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); // Ensure asyndeton node is in relations
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            // Add Asyndeton node if applicable
            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                // Ensure asyndeton node (ID 0) is always first if present
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { // Allow Mode 4 if asyndeton node + 0 real tokens, or >1 real tokens
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
This works well. A minor fix: could you ensure that in highlighting what verbal unit a token is assigned to, each verbal unit is represented by a different randomly chosen color?

### ASSISTANT
You're looking for a clear visual distinction for tokens belonging to different verbal units, which is a great UI refinement!

The good news is that the current implementation should already achieve this. Let's briefly review why:

1.  **Unique Color Generation per Verbal Unit**:
    In the `handleConfirmVerbalUnit` function, when a new verbal unit is created, we call `generateRandomColor()` and store its result in the `color` property of that specific verbal unit object:
    ```javascript
    // Inside handleConfirmVerbalUnit
    ann.verbalUnits.push({ 
        id: Date.now(), 
        syntacticType, 
        semanticType, 
        depth,
        color: generateRandomColor(), // <-- A new random color is generated here for THIS verbal unit
        assignedTokenURNs: [] 
    });
    ```
    This means `verbalUnit1` will have its own `color` property (e.g., `rgba(10,50,120,0.5)`) and `verbalUnit2` will have its own, different `color` property (e.g., `rgba(150,20,90,0.5)`), assuming the random generation produces distinct values (which is highly probable).

2.  **Using the Specific Verbal Unit's Color for Highlighting**:
    In the `displaySentenceTokens` function, when determining the highlight for a token, the code iterates through all defined verbal units. If a token is found to be assigned to a particular verbal unit (`vu`), it uses `vu.color` (the color stored specifically for *that* verbal unit) for the highlight:
    ```javascript
    // Inside displaySentenceTokens
    if (currentAnn.verbalUnits) {
        for (const vu of currentAnn.verbalUnits) { // Loop through each verbal unit
            if (vu.assignedTokenURNs.includes(token.urn)) { // If the token is in THIS verbal unit
                // Use THIS verbal unit's stored color for the highlight
                tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                break; // Token found in a VU, apply its color and stop checking for this token
            }
        }
    }
    ```
    This logic ensures that tokens assigned to `verbalUnit1` get `verbalUnit1.color`, and tokens assigned to `verbalUnit2` (if different from `verbalUnit1`) get `verbalUnit2.color`.

**Therefore, no changes to the code are strictly necessary to meet this specific requirement, as the existing structure already assigns a unique random color to each verbal unit and uses that specific color for its tokens.**

If you are observing tokens from different verbal units appearing with the same highlight color (beyond sheer random chance of two VUs getting identical RGBA values), there might be a more subtle issue or a misunderstanding of a specific scenario. The described mechanism, however, is designed to provide distinct colors per verbal unit.

Here is the full HTML code again for completeness, with the relevant sections for color generation and application functioning as described above.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
    </div>

    <div id="sentenceDisplayArea" class="hidden">
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) {
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                return;
            }

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden');
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Great! I'd like to make two minor adjustments to the display without in any way changing the functionality. 1) Could you position the block labelled "Sentence Text" below the block labelled "Annotation Mode 1: Asyndeton / Connecting Word" and above the block labelled "Annotation Mode 2: Verbal Units"? 2) When the user chooses a sentence from the menu, could you display right below the menu the integer index of the user's choice? This value should be 1-based, disregarding the labelling instruction "-- Select a sentence --". **Example**: if the user chose the first item after "-- Select a sentence --", the index value would be `1`.

### ASSISTANT
Okay, those are good UI refinements!

Here's the updated HTML and JavaScript:

1.  The "Sentence Text" block (`sentenceDisplayArea`) has been moved.
2.  A new paragraph (`<p id="selectedSentenceIndexDisplay">`) has been added below the sentence dropdown to show the 1-based index.

Here is the complete updated file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, #annotationMode1, #annotationMode2, #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> <!-- MOVED HERE -->
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements (IDs are fetched here)
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); // New element
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                selectedSentenceIndexDisplay.textContent = ''; // Clear index on new data load
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { // Placeholder selected
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; // Clear index display
                return;
            }

            // Display 1-based index of the selected sentence
            selectedSentenceIndexDisplay.textContent = `Sentence index: ${sentenceDropdown.selectedIndex}`;


            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
            }
            checkAndEnableMode4(); 
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Great! Let's alter the page layout by moving the section "Sentence Text" _after_ (below) section "Annotation Mode 2: Verbal Units". Then immediately after that, let's add a further display of the `text` property of all tokens assigned to a verbal unit, as follows: if a token belongs to the same verbal unit as the preceding token, it continues on the same line. If it belongs to a different verbal unit, it begins a new line. Line beginnings should be indented according to the depth value of the verbal unit. Level 1 verbal units should be flush left; level 2 units should be indented one level further; etc. Tokens on the same line should be separated by a single white space.

### ASSISTANT
Okay, these are good UI adjustments for clarity and workflow!

Here's the updated HTML and JavaScript to reflect these changes:

1.  The "Sentence Text" block (`sentenceDisplayArea`) is moved below "Annotation Mode 2: Verbal Units".
2.  A new display block, "Verbal Unit Token Grouping" (`verbalUnitTokenGroupingArea`), is added immediately after the "Sentence Text" block.
3.  The 1-based index of the selected sentence is displayed below the sentence dropdown.

And here's the complete updated file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { /* For lines in the new display */
            margin-bottom: 2px; /* Small gap between lines */
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> <!-- MOVED HERE -->
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> <!-- NEW DISPLAY BLOCK -->
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace;"></div>
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); // New
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); // New
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceDropdown.selectedIndex}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); // Initial call after sentence change
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; // Clear this display if Mode 2 not active
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU = null;

            for (const token of currentSentenceTokens) {
                if (token.type !== 'lexical') continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        // Depth 0 = level 1, flush left. Depth 1 = level 2, indent 1 unit.
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU = currentTokenVU;
                } else {
                    previousTokenVU = null; 
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Beautiful! Could you make the text size in the new "Verbal Unit Token Grouping" display a little larger?

### ASSISTANT
Okay, that's a simple and effective tweak for better readability!

We can adjust the font size for the "Verbal Unit Token Grouping" display directly in its inline style. I'll set it to `1.1em` to make it slightly larger than the default body text.

Here's the updated HTML with that small change. Only the `div` for `verbalUnitTokenGroupingDisplay` needs its style attribute modified.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { 
            margin-bottom: 2px; 
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> 
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> 
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace; font-size: 1.1em;"></div> {/* FONT SIZE ADJUSTED HERE */}
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); 
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); 
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceDropdown.selectedIndex}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); 
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const selectedVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                const tokenIndexInVU = selectedVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInVU > -1) { 
                    selectedVU.assignedTokenURNs.splice(tokenIndexInVU, 1);
                } else { 
                    selectedVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; 
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU = null;

            // Sort tokens by sequence for consistent display order
            const sortedTokens = [...currentSentenceTokens].sort((a, b) => a.sequence - b.sequence);

            for (const token of sortedTokens) {
                if (token.type !== 'lexical') continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        // Depth 0 means level 1, flush left. Depth 1 means level 2, indent 1 unit.
                        // Padding should be (depth - 1) * indent_unit if depth is 1-based for levels.
                        // Or if depth is 0-based: depth 0 = no indent, depth 1 = 1 unit indent.
                        // The prompt says "Level 1 ... flush left; level 2 ... indented one level further"
                        // Assuming VU depth is 1-based for these levels for indentation.
                        // If VU.depth is 0, it means level 1, so (vu.depth) * indent is 0.
                        // If VU.depth is 1, it means level 2, so (vu.depth) * indent is 1 * indent. This works.
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU = currentTokenVU;
                } else {
                    // If a token is not in any VU, it breaks the sequence for the next VU token
                    previousTokenVU = null; 
                    currentLineDiv = null; // Ensure next VU token starts a new line
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
  
Excellent! Let's modify the clicking behavior when assigning tokens to a verbal unit so that the user can change the assignment of a token: that is, so the user can assign a token to the current verbal unit, even if it's already been assigned to a different one. User click should override any previous assignment.

### ASSISTANT
Okay, this change makes the token assignment in Mode 3 more flexible, allowing users to re-assign tokens without first having to de-assign them.

Here's how we'll adjust the `handleLexicalTokenClick` function for Mode 3:

1.  When a token is clicked and Mode 3 is active with a selected verbal unit:
    *   We first iterate through *all* verbal units to see if the clicked token is currently assigned to *any* of them.
    *   If it is assigned to a different verbal unit, we remove it from that other unit's `assignedTokenURNs` list.
    *   Then, we check if the token is in the *currently selected* verbal unit.
        *   If it is, we remove it (toggle off).
        *   If it's not (or was just removed from another VU), we add it to the currently selected verbal unit.

This ensures a token can only belong to one verbal unit at a time, and clicking assigns it to the *currently selected* VU, overriding any prior assignment.

Here's the updated HTML with the modified `handleLexicalTokenClick` function:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4 {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { 
            margin-bottom: 2px; 
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> 
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> 
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace; font-size: 1.1em;"></div> 
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); 
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); 
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceURNs.forEach(urn => sentenceDropdown.appendChild(new Option(urn, urn)));

                sentenceSelectorDiv.classList.remove('hidden');
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceDropdown.selectedIndex}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); 
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const currentVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                let wasInAnotherVU = false;

                // Check if token is in any *other* VU and remove it
                for (let i = 0; i < ann.verbalUnits.length; i++) {
                    if (i === currentSelectedVerbalUnitIndex) continue; // Skip the currently selected VU for now
                    const otherVU = ann.verbalUnits[i];
                    const tokenIndexInOtherVU = otherVU.assignedTokenURNs.indexOf(urn);
                    if (tokenIndexInOtherVU > -1) {
                        otherVU.assignedTokenURNs.splice(tokenIndexInOtherVU, 1);
                        wasInAnotherVU = true;
                    }
                }

                // Now handle assignment to the *current* VU
                const tokenIndexInCurrentVU = currentVU.assignedTokenURNs.indexOf(urn);

                if (tokenIndexInCurrentVU > -1) {
                    // Token is in the current VU, so clicking means unassign (toggle off)
                    currentVU.assignedTokenURNs.splice(tokenIndexInCurrentVU, 1);
                } else {
                    // Token is not in the current VU (or was just removed from another), so assign it
                    currentVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text);
                }
                
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; 
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU = null;

            const sortedTokens = [...currentSentenceTokens].sort((a, b) => a.sequence - b.sequence);

            for (const token of sortedTokens) {
                if (token.type !== 'lexical') continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU = currentTokenVU;
                } else {
                    previousTokenVU = null; 
                    currentLineDiv = null; 
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT);
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

    </script>
</body>
</html>
```

### USER
Great! I’m thinking about adding a download option but first I need to know: if a user annotates multiple sentences do you keep track of them all or just the current one.  (Either way is fine.)

### ASSISTANT
Yes, the current implementation **does keep track of annotations for all sentences** that the user annotates during a single session.

The `annotations` object is structured like this:

```javascript
annotations = {
    "urn:cts:greekLit:tlg001.tlg001.msA:1.1": { // Sentence 1 URN
        asyndeton: true,
        connectingWordURN: null,
        verbalUnits: [ /* ... VUs for sentence 1 ... */ ],
        tokenRelations: { /* ... relations for sentence 1 ... */ }
    },
    "urn:cts:greekLit:tlg001.tlg001.msA:1.2": { // Sentence 2 URN
        asyndeton: false,
        connectingWordURN: "urn:cts:greekLit:tlg001.tlg001.msA:1.2.3", // example
        verbalUnits: [ /* ... VUs for sentence 2 ... */ ],
        tokenRelations: { /* ... relations for sentence 2 ... */ }
    },
    // ... and so on for other annotated sentences
};
```

When you select a sentence from the dropdown:
1.  `currentSentenceURN` is updated.
2.  `getCurrentSentenceAnnotation()` is called, which either retrieves the existing annotations for that `currentSentenceURN` from the `annotations` object or initializes a new entry for it if it's the first time that sentence is being annotated.

So, all the work done on different sentences is preserved within that global `annotations` object, keyed by the unique sentence URN. This is perfect for eventually implementing a download option that would export all the accumulated annotation data for the session.

### USER
What about the verbal unit definitions? Do you keep those across multiple sentences too?

### ASSISTANT
Yes, the verbal unit definitions are also **kept track of for each sentence individually**, just like the other annotations.

Here's why:

1.  **Structure of `annotations` Object**:
    The main `annotations` object is keyed by the sentence URN. Each entry for a sentence contains its own `verbalUnits` array:

    ```javascript
    annotations = {
        "sentence_urn_1": {
            asyndeton: ...,
            connectingWordURN: ...,
            verbalUnits: [ // VUs for sentence 1
                { id: 123, syntacticType: "independent clause", depth: 0, color: "...", assignedTokenURNs: ["urn_a", "urn_b"] },
                { id: 456, syntacticType: "subordinate clause", depth: 1, color: "...", assignedTokenURNs: ["urn_c"] }
            ],
            tokenRelations: { ... }
        },
        "sentence_urn_2": {
            asyndeton: ...,
            connectingWordURN: ...,
            verbalUnits: [ // VUs for sentence 2
                { id: 789, syntacticType: "circumstantial participle", depth: 0, color: "...", assignedTokenURNs: ["urn_x", "urn_y", "urn_z"] }
            ],
            tokenRelations: { ... }
        },
        // ...
    };
    ```

2.  **How Verbal Units are Handled**:
    *   When you **add a new verbal unit** (`handleConfirmVerbalUnit`), it's pushed into the `verbalUnits` array of the *currently selected sentence's annotation object* (`ann.verbalUnits.push(...)`).
    *   When you **display the table of verbal units** (`renderVerbalUnitsTable`), it iterates over the `verbalUnits` array of the *currently selected sentence*.
    *   When you **assign tokens to a verbal unit** in Mode 3 (`handleLexicalTokenClick`), the token's URN is added to or removed from the `assignedTokenURNs` array of a specific verbal unit object, which itself is part of the *currently selected sentence's* `verbalUnits` list.

**In summary:**

*   Each sentence has its own distinct set of verbal unit definitions.
*   The syntactic type, semantic type, depth, color, and the list of tokens assigned to a verbal unit are all specific to that verbal unit within that particular sentence.
*   If you define verbal units for sentence A and then switch to sentence B, sentence B will either have its own previously defined verbal units or (if new) an empty list of verbal units. The definitions from sentence A are not automatically carried over or shared with sentence B.

This is generally the desired behavior, as the clausal structure and verbal units are typically unique to each sentence.

### USER
OK, let's try this. Add an option for the user to download the annotations data. We'll write data for sentences, verbal units, and tokens to a single plain-text file, with 3 blocks of delimited-text data.
  
The first block will begin with a labelling line `#!sentences`, followed by a pipe-delimited header line `sentence|sequence|connector`. This will be followed by one line for each annotated sentence, with three pipe-delimited columns. The first column will be the identifier for the sentence in the form used in the user menu. The second column will be the sequence number of that sentence in the menu. The third column will be an identifier for the connecting word, or empty if the sentence illustrates asyndeton. The identifier to use is the `urn` property of the `Token` object that the user chose as the connecting word.
**Example**: If the user chose a sentence identifier `urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.1-1.6.46a`, and it was the tenth sentence in the menu, then chose a token with text value `γὰρ` that was identified by the `urn` property `urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.2`, that would be represented with this line:
  
`urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.1-1.6.46a|10|urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.2`
  
  
The second block will begin with a labelling line `#!verbal_units`, then the pipe-delimited header line `vuid|syntactic_type|semantic_type|depth|sentence`, followed by one pipe-delimited line of data for each verbal unit. `vuid` is a unique id for this verbal unit; `syntactic_type`, `semantic_type`, and `depth` are the values of the columns "Syntactic type", "Semantic type",  and "Depth", respectively. `sentence` is the same ID value for the sentence that was used in the first block of sentences (and hence can be used by other applications to join verbal units and sentences)
  
The third block will begin with a labelling line  `#!tokens`, then the pipe-delimited header line `urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation`.  This will be followed by one line for each token assigned to a verbal unit. It is very important that for the first column record the value of the `urn` property of the `Token` object that was annotated. The remaining columns will have the values of the columns "Reference", "Token", "Node 1 (ID)", "Node 1 Relation", "Node 2 (ID)", and "Node 2 Relation" from the user-edited table.
  
Please implement this.

### ASSISTANT
Okay, this is a great addition, allowing users to persist and reuse their valuable annotation work!

Here's how we'll implement the download functionality:

1.  **Add a Download Button**: We'll add a button to the UI, probably in a general area, not tied to a specific mode.
2.  **`handleDownloadAnnotations` Function**: This new function will be triggered by the download button.
3.  **Data Compilation**: Inside this function, we'll iterate through the `annotations` object.
    *   **Sentences Block**:
        *   Get all sentence URNs present as keys in the `annotations` object.
        *   For each URN, find its 1-based index in the `sentenceDropdown`.
        *   Extract the `connectingWordURN` (or an empty string if `asyndeton` is true).
    *   **Verbal Units Block**:
        *   Iterate through each sentence's `verbalUnits` array.
        *   For each verbal unit, generate a unique `vuid` (we can use the `vu.id` which is `Date.now()` from when it was created, or generate a new sequential one for the download). Let's stick with `vu.id` for now as it's already unique within the session.
        *   Extract `syntacticType`, `semanticType`, `depth`, and the parent sentence's URN.
    *   **Tokens Block**:
        *   Iterate through each sentence's `tokenRelations` object.
        *   For each token sequence (which is the `reference`):
            *   We need the token's original `urn` and `type`. This requires looking up the token in the `currentSentenceTokens` array (or `allTokens` if we store it differently for download). Since `tokenRelations` is keyed by sequence, and we have `currentSentenceTokens` available when a sentence is active, we should be able to get this. For tokens not currently active, we'd need a way to map sequence back to URN/type or store it directly in `tokenRelations` upon first encounter. Let's ensure `tokenRelations` stores the original URN and we can derive the type if needed or store it.
            *   Actually, the prompt for `#!tokens` says: "for the first column record the value of the `urn` property of the `Token` object that was annotated." This is good. We already store `tokenText` in `tokenRelations`. We will need to ensure we can get the original token URN for each entry in `tokenRelations`. The easiest way is to ensure `tokenRelations` also stores the `urn` when an entry is created/updated for a token. The "asyndeton" node will need special handling for its URN.
            *   Extract `reference` (the sequence), `text` (from `tokenRelations.tokenText`), `verbalunit` (the `vuid` of the verbal unit it's assigned to - a token can only be in one), and the node/relation data.
4.  **Formatting and File Creation**:
    *   Concatenate the data for each block into strings.
    *   Join the blocks with newlines.
    *   Create a `Blob` with the text data.
    *   Use an `<a>` element with a `download` attribute and `href` pointing to the Blob's URL to trigger the download.

Let's refine the `tokenRelations` structure slightly to ensure we have the token's URN and potentially its original `type` if needed for the download output. When a token is first added to `tokenRelations` (e.g., when it becomes a connecting word, is assigned to a VU, or is simply part of the Mode 4 table), we'll store its URN there.

Here's the updated HTML and JavaScript:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4, #downloadArea { /* Added #downloadArea */
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { 
            margin-bottom: 2px; 
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="downloadArea" class="hidden"> <!-- New Download Area -->
        <h2>Download Annotations</h2>
        <button id="downloadAnnotationsButton">Download Data</button>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> 
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> 
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace; font-size: 1.1em;"></div> 
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 
        let sentenceUrnMap = {}; // To map URN to original index in allTokens

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const downloadAreaDiv = document.getElementById('downloadArea'); // New
        const downloadAnnotationsButton = document.getElementById('downloadAnnotationsButton'); // New
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); 
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); 
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        downloadAnnotationsButton.addEventListener('click', handleDownloadAnnotations); // New listener
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceUrnMap = {}; // Reset map
                sentenceURNs.forEach((urn, index) => {
                    sentenceDropdown.appendChild(new Option(urn, urn));
                    sentenceUrnMap[urn] = index + 1; // Store 1-based index
                });

                sentenceSelectorDiv.classList.remove('hidden');
                downloadAreaDiv.classList.remove('hidden'); // Show download once data is loaded
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceUrnMap[currentSentenceURN]}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); 
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText, tokenUrn, tokenType) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    originalUrn: tokenUrn, // Store original URN for download
                    originalType: tokenType, // Store original type for download
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
                ann.tokenRelations[tokenSequence].originalUrn = tokenUrn;
                ann.tokenRelations[tokenSequence].originalType = tokenType;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const currentVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                
                // Remove token from any other VU first
                for (let i = 0; i < ann.verbalUnits.length; i++) {
                    if (i === currentSelectedVerbalUnitIndex) continue; 
                    const otherVU = ann.verbalUnits[i];
                    const tokenIndexInOtherVU = otherVU.assignedTokenURNs.indexOf(urn);
                    if (tokenIndexInOtherVU > -1) {
                        otherVU.assignedTokenURNs.splice(tokenIndexInOtherVU, 1);
                    }
                }

                const tokenIndexInCurrentVU = currentVU.assignedTokenURNs.indexOf(urn);
                if (tokenIndexInCurrentVU > -1) {
                    currentVU.assignedTokenURNs.splice(tokenIndexInCurrentVU, 1);
                } else {
                    currentVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                }
                
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal"); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; 
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), // This serves as vuid
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU = null;

            const sortedTokens = [...currentSentenceTokens].sort((a, b) => a.sequence - b.sequence);

            for (const token of sortedTokens) {
                if (token.type !== 'lexical') continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU = currentTokenVU;
                } else {
                    previousTokenVU = null; 
                    currentLineDiv = null; 
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN, type: "internal" });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn, type: cwToken.type });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn, type: token.type });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text, token.urn, token.type);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text, token.urn, token.type);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

        function handleDownloadAnnotations() {
            let output = "";

            // SENTENCES BLOCK
            const sentencesHeader = "sentence|sequence|connector";
            const sentencesData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    const sentenceMenuIndex = sentenceUrnMap[sentenceUrn] || ''; // Get 1-based index from map
                    const connectorUrn = ann.asyndeton ? '' : (ann.connectingWordURN || '');
                    sentencesData.push(`${sentenceUrn}|${sentenceMenuIndex}|${connectorUrn}`);
                }
            }
            if (sentencesData.length > 0) {
                 output += "#!sentences\n";
                 output += sentencesHeader + "\n";
                 output += sentencesData.join("\n") + "\n\n";
            }


            // VERBAL UNITS BLOCK
            const verbalUnitsHeader = "vuid|syntactic_type|semantic_type|depth|sentence";
            const verbalUnitsData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.verbalUnits) {
                        ann.verbalUnits.forEach(vu => {
                            verbalUnitsData.push(`${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${sentenceUrn}`);
                        });
                    }
                }
            }
             if (verbalUnitsData.length > 0) {
                output += "#!verbal_units\n";
                output += verbalUnitsHeader + "\n";
                output += verbalUnitsData.join("\n") + "\n\n";
            }

            // TOKENS BLOCK
            const tokensHeader = "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation";
            const tokensData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.tokenRelations) {
                        for (const refSeq in ann.tokenRelations) {
                            if (ann.tokenRelations.hasOwnProperty(refSeq)) {
                                const relData = ann.tokenRelations[refSeq];
                                
                                // Find which verbal unit this token (by originalUrn) is assigned to
                                let assignedVuId = '';
                                if (ann.verbalUnits && relData.originalUrn !== ASYNDETON_NODE_URN) {
                                    for (const vu of ann.verbalUnits) {
                                        if (vu.assignedTokenURNs.includes(relData.originalUrn)) {
                                            assignedVuId = vu.id;
                                            break;
                                        }
                                    }
                                }

                                tokensData.push([
                                    relData.originalUrn || '',         // urn
                                    refSeq,                            // reference
                                    relData.originalType || '',        // tokentype
                                    relData.tokenText || '',           // text
                                    assignedVuId,                      // verbalunit
                                    relData.node1Sequence !== null ? relData.node1Sequence : '', // node1
                                    relData.node1Rel || '',            // node1relation
                                    relData.node2Sequence !== null ? relData.node2Sequence : '', // node2
                                    relData.node2Rel || ''             // node2relation
                                ].join("|"));
                            }
                        }
                    }
                }
            }
            if (tokensData.length > 0) {
                output += "#!tokens\n";
                output += tokensHeader + "\n";
                output += tokensData.join("\n") + "\n";
            }
            

            if (output.trim() === "") {
                alert("No annotations to download.");
                return;
            }

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'greek_annotations.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Great! Let's move the "Download Annotations" section to the bottom of the page, below the table where the user edits relations of tokens. Can you let the user select a name for the local output file, with a default of "greek_annotations.cex" ?

### ASSISTANT
Okay, those are good refinements for the download functionality and page layout!

Here's the updated HTML and JavaScript to:
1.  Move the "Download Annotations" section to the bottom.
2.  Allow the user to specify the output filename, defaulting to "greek_annotations.cex".

Here is the complete updated file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4, #downloadArea { 
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { 
            margin-bottom: 2px; 
        }
        #downloadFilenameInput { /* Style for the new filename input */
            width: 250px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> 
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> 
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace; font-size: 1.1em;"></div> 
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <div id="downloadArea" class="hidden"> <!-- MOVED TO BOTTOM (before script) -->
        <h2>Download Annotations</h2>
        <label for="downloadFilenameInput">Filename:</label>
        <input type="text" id="downloadFilenameInput" value="greek_annotations.cex">
        <button id="downloadAnnotationsButton">Download Data</button>
    </div>


    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 
        let sentenceUrnMap = {}; 

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const downloadAreaDiv = document.getElementById('downloadArea'); 
        const downloadFilenameInput = document.getElementById('downloadFilenameInput'); // New
        const downloadAnnotationsButton = document.getElementById('downloadAnnotationsButton'); 
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); 
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); 
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        downloadAnnotationsButton.addEventListener('click', handleDownloadAnnotations); 
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceUrnMap = {}; 
                sentenceURNs.forEach((urn, index) => {
                    sentenceDropdown.appendChild(new Option(urn, urn));
                    sentenceUrnMap[urn] = index + 1; 
                });

                sentenceSelectorDiv.classList.remove('hidden');
                downloadAreaDiv.classList.remove('hidden'); 
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceUrnMap[currentSentenceURN]}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); 
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText, tokenUrn, tokenType) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    originalUrn: tokenUrn, 
                    originalType: tokenType, 
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
                ann.tokenRelations[tokenSequence].originalUrn = tokenUrn;
                ann.tokenRelations[tokenSequence].originalType = tokenType;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const currentVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                
                for (let i = 0; i < ann.verbalUnits.length; i++) {
                    if (i === currentSelectedVerbalUnitIndex) continue; 
                    const otherVU = ann.verbalUnits[i];
                    const tokenIndexInOtherVU = otherVU.assignedTokenURNs.indexOf(urn);
                    if (tokenIndexInOtherVU > -1) {
                        otherVU.assignedTokenURNs.splice(tokenIndexInOtherVU, 1);
                    }
                }

                const tokenIndexInCurrentVU = currentVU.assignedTokenURNs.indexOf(urn);
                if (tokenIndexInCurrentVU > -1) {
                    currentVU.assignedTokenURNs.splice(tokenIndexInCurrentVU, 1);
                } else {
                    currentVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                }
                
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal"); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; 
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU = null;

            const sortedTokens = [...currentSentenceTokens].sort((a, b) => a.sequence - b.sequence);

            for (const token of sortedTokens) {
                if (token.type !== 'lexical') continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU = currentTokenVU;
                } else {
                    previousTokenVU = null; 
                    currentLineDiv = null; 
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN, type: "internal" });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn, type: cwToken.type });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn, type: token.type });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text, token.urn, token.type);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;


            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
            } else {
                annotationMode4Div.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text, token.urn, token.type);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            populateTokenRelationsTable(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations); 
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

        function handleDownloadAnnotations() {
            let output = "";

            const sentencesHeader = "sentence|sequence|connector";
            const sentencesData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    const sentenceMenuIndex = sentenceUrnMap[sentenceUrn] || ''; 
                    const connectorUrn = ann.asyndeton ? '' : (ann.connectingWordURN || '');
                    sentencesData.push(`${sentenceUrn}|${sentenceMenuIndex}|${connectorUrn}`);
                }
            }
            if (sentencesData.length > 0) {
                 output += "#!sentences\n";
                 output += sentencesHeader + "\n";
                 output += sentencesData.join("\n") + "\n\n";
            }

            const verbalUnitsHeader = "vuid|syntactic_type|semantic_type|depth|sentence";
            const verbalUnitsData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.verbalUnits) {
                        ann.verbalUnits.forEach(vu => {
                            verbalUnitsData.push(`${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${sentenceUrn}`);
                        });
                    }
                }
            }
             if (verbalUnitsData.length > 0) {
                output += "#!verbal_units\n";
                output += verbalUnitsHeader + "\n";
                output += verbalUnitsData.join("\n") + "\n\n";
            }

            const tokensHeader = "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation";
            const tokensData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.tokenRelations) {
                        for (const refSeq in ann.tokenRelations) {
                            if (ann.tokenRelations.hasOwnProperty(refSeq)) {
                                const relData = ann.tokenRelations[refSeq];
                                
                                let assignedVuId = '';
                                if (ann.verbalUnits && relData.originalUrn !== ASYNDETON_NODE_URN) {
                                    for (const vu of ann.verbalUnits) {
                                        if (vu.assignedTokenURNs.includes(relData.originalUrn)) {
                                            assignedVuId = vu.id;
                                            break;
                                        }
                                    }
                                }

                                tokensData.push([
                                    relData.originalUrn || '',         
                                    refSeq,                            
                                    relData.originalType || '',        
                                    relData.tokenText || '',           
                                    assignedVuId,                      
                                    relData.node1Sequence !== null ? relData.node1Sequence : '', 
                                    relData.node1Rel || '',            
                                    relData.node2Sequence !== null ? relData.node2Sequence : '', 
                                    relData.node2Rel || ''             
                                ].join("|"));
                            }
                        }
                    }
                }
            }
            if (tokensData.length > 0) {
                output += "#!tokens\n";
                output += tokensHeader + "\n";
                output += tokensData.join("\n") + "\n";
            }
            

            if (output.trim() === "") {
                alert("No annotations to download.");
                return;
            }

            const filename = downloadFilenameInput.value.trim() || "greek_annotations.cex";
            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Excellent. Two tiny tweaks. 1) Let's keep the "Download Annotations" section hidden until the user has actually defined at least one token realtion in Mode 4.
  
2) In the "Verbal Unit Token Grouping" section, we should ignore any connecting word the user has identified. **Example**: Consider a sequence where, of the first 3 tokens, where token 1 belongs to verbal unit 1, token 2 is the connector token, and token 3 belongs to verbal unit. We place token 1 on a line to start the display. We ignore token 2 because it's the connector token. We see that connector 3 belongs to verbal unit 1 and look at the preceding token -- but here that means we should look at token 1 since we're ignoring the connector. We see that token 1 also belongs to verbal unit 1, so we continue token 3 on the same line.
  
Could you implement this?

### ASSISTANT
Okay, these are good final refinements to the UI logic!

Here's how we'll adjust the code:

1.  **Hide/Show Download Area**:
    *   The `downloadAreaDiv` will start hidden.
    *   We'll modify `checkAndEnableMode4` (or a similar central place where Mode 4's state is determined). If Mode 4 becomes active *and* there are actual relations defined (i.e., not just the asyndeton node or empty relations), then we show the `downloadAreaDiv`. If Mode 4 is hidden or has no relations, the download area is hidden. We'll also check this when relations are modified in the table.

2.  **Verbal Unit Token Grouping - Ignoring Connector**:
    *   In `renderVerbalUnitTokenGrouping`, when iterating through `sortedTokens`, we will explicitly skip the `connectingWordURN` if it's set for the current sentence.
    *   The logic for `previousTokenVU` will need to correctly track the last *non-connector* token that was part of a VU.

Here's the updated HTML with the modified JavaScript:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        #dataLoader, #sentenceSelector, #sentenceDisplayArea, 
        #annotationMode1, #annotationMode2, #verbalUnitTokenGroupingArea, 
        #annotationMode3, #annotationMode4, #downloadArea { 
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        label {
            margin-right: 10px;
        }
        input[type="text"], input[type="number"], select {
            padding: 5px;
            margin-right: 10px;
            min-width: 100px; 
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
            margin: 2px;
        }
        #statusMessage {
            font-style: italic;
            color: #555;
        }
        .lexical-token {
            cursor: pointer;
            padding: 1px 2px; 
            border-radius: 3px;
        }
        .lexical-token.connecting-word-highlight {
            background-color: yellow; 
        }
        sup {
            color: silver;
            font-size: smaller;
            vertical-align: super;
            margin-left: 1px;
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
        }
        #newVerbalUnitForm table td {
            border: none;
            padding: 5px 0;
        }
        #newVerbalUnitForm {
            padding: 10px;
            border: 1px dashed #ccc;
            margin-top: 10px;
        }
        #mermaidGraphContainer {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
        }
        .mermaid {
            text-align: center;
        }
        #tokenRelationsTable input[type="number"] {
            width: 60px;
        }
        #tokenRelationsTable select { 
            width: 150px;
        }
        #selectedSentenceIndexDisplay {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #verbalUnitTokenGroupingDisplay div { 
            margin-bottom: 2px; 
        }
        #downloadFilenameInput { 
            width: 250px;
        }
    </style>
</head>
<body>
    <h1>Greek Text Annotator</h1>

    <div id="dataLoader">
        <label for="cexUrl">CEX URL:</label>
        <input type="text" id="cexUrl" size="80" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/lysias1.cex">
        <button id="loadButton">Load Data</button>
        <p id="statusMessage">Enter a CEX URL and click "Load Data".</p>
    </div>

    <div id="sentenceSelector" class="hidden">
        <label for="sentenceDropdown">Select Sentence:</label>
        <select id="sentenceDropdown"></select>
        <p id="selectedSentenceIndexDisplay"></p> 
    </div>

    <div id="annotationMode1" class="hidden">
        <h2>Annotation Mode 1: Asyndeton / Connecting Word</h2>
        <label><input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates <em>asyndeton</em>.</label>
        <p id="mode1Instruction">If not <em>asyndeton</em>, please click the <em>connecting word</em> in the sentence above.</p>
        <p id="mode1CompletionStatus" style="font-weight: bold;"></p>
    </div>
    
    <div id="annotationMode2" class="hidden">
        <h2>Annotation Mode 2: Verbal Units</h2>
        <button id="addVerbalUnitBtn">Add New Verbal Unit</button>
        <div id="newVerbalUnitForm" class="hidden">
            <h3>Add New Verbal Unit</h3>
            <table>
                <tr><td><label for="newVuSyntacticType">Syntactic Type:</label></td><td><select id="newVuSyntacticType"></select></td></tr>
                <tr><td><label for="newVuSemanticType">Semantic Type:</label></td><td><select id="newVuSemanticType"></select></td></tr>
                <tr><td><label for="newVuDepth">Depth:</label></td><td><input type="number" id="newVuDepth" min="0" value="0"></td></tr>
            </table>
            <button id="confirmNewVuBtn">Confirm Unit</button>
            <button id="cancelNewVuBtn">Cancel</button>
        </div>
        <table id="verbalUnitsTable">
            <thead><tr><th>Syntactic type</th><th>Semantic type</th><th>Depth</th><th>Tokens Assigned</th><th>Actions</th></tr></thead>
            <tbody id="verbalUnitsTableBody"></tbody>
        </table>
    </div>

    <div id="sentenceDisplayArea" class="hidden"> 
        <h2>Sentence Text</h2>
        <div id="sentenceDisplay" style="font-size: 1.2em; line-height: 2;"></div>
    </div>

    <div id="verbalUnitTokenGroupingArea" class="hidden"> 
        <h2>Verbal Unit Token Grouping</h2>
        <div id="verbalUnitTokenGroupingDisplay" style="font-family: monospace; font-size: 1.1em;"></div> 
    </div>

    <div id="annotationMode3" class="hidden">
        <h2>Annotation Mode 3: Assign Tokens to Verbal Unit</h2>
        <label for="verbalUnitSelectForAssignment">Select Verbal Unit to Assign Tokens:</label>
        <select id="verbalUnitSelectForAssignment"></select>
        <p>Click on lexical tokens in the sentence display above to assign/unassign them from the selected verbal unit.</p>
        <p id="mode3Status" style="font-weight: bold;"></p>
    </div>

    <div id="annotationMode4" class="hidden">
        <h2 id="mode4Header">Annotation Mode 4: Token Relations</h2>
        <div id="mermaidGraphContainer">
            <div id="mermaidDiv" class="mermaid">
                <!-- Mermaid graph will be rendered here -->
            </div>
        </div>
        <table id="tokenRelationsTable">
            <thead>
                <tr>
                    <th>Reference</th>
                    <th>Token</th>
                    <th>Node 1 (ID)</th>
                    <th>Node 1 Relation</th>
                    <th>Node 2 (ID)</th>
                    <th>Node 2 Relation</th>
                </tr>
            </thead>
            <tbody id="tokenRelationsTableBody"></tbody>
        </table>
         <p id="mode4Status" style="font-weight: bold;"></p>
    </div>

    <div id="downloadArea" class="hidden"> 
        <h2>Download Annotations</h2>
        <label for="downloadFilenameInput">Filename:</label>
        <input type="text" id="downloadFilenameInput" value="greek_annotations.cex">
        <button id="downloadAnnotationsButton">Download Data</button>
    </div>


    <script>
        mermaid.initialize({ startOnLoad: false, theme: 'default' });

        // Global variables
        let allTokens = []; 
        let currentSentenceTokens = []; 
        let currentSentenceURN = null;
        let annotations = {}; 
        let currentSelectedVerbalUnitIndex = -1; 
        let sentenceUrnMap = {}; 

        // UI Elements 
        const cexUrlInput = document.getElementById('cexUrl');
        const loadButton = document.getElementById('loadButton');
        const statusMessage = document.getElementById('statusMessage');
        const downloadAreaDiv = document.getElementById('downloadArea'); 
        const downloadFilenameInput = document.getElementById('downloadFilenameInput'); 
        const downloadAnnotationsButton = document.getElementById('downloadAnnotationsButton'); 
        const sentenceSelectorDiv = document.getElementById('sentenceSelector');
        const sentenceDropdown = document.getElementById('sentenceDropdown');
        const selectedSentenceIndexDisplay = document.getElementById('selectedSentenceIndexDisplay'); 
        const sentenceDisplayAreaDiv = document.getElementById('sentenceDisplayArea');
        const sentenceDisplay = document.getElementById('sentenceDisplay');
        const annotationMode1Div = document.getElementById('annotationMode1');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Instruction = document.getElementById('mode1Instruction');
        const mode1CompletionStatus = document.getElementById('mode1CompletionStatus');
        const annotationMode2Div = document.getElementById('annotationMode2');
        const addVerbalUnitBtn = document.getElementById('addVerbalUnitBtn');
        const newVerbalUnitForm = document.getElementById('newVerbalUnitForm');
        const newVuSyntacticTypeSelect = document.getElementById('newVuSyntacticType');
        const newVuSemanticTypeSelect = document.getElementById('newVuSemanticType');
        const newVuDepthInput = document.getElementById('newVuDepth');
        const confirmNewVuBtn = document.getElementById('confirmNewVuBtn');
        const cancelNewVuBtn = document.getElementById('cancelNewVuBtn');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTableBody');
        const verbalUnitTokenGroupingArea = document.getElementById('verbalUnitTokenGroupingArea'); 
        const verbalUnitTokenGroupingDisplay = document.getElementById('verbalUnitTokenGroupingDisplay'); 
        const annotationMode3Div = document.getElementById('annotationMode3');
        const verbalUnitSelectForAssignment = document.getElementById('verbalUnitSelectForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        const annotationMode4Div = document.getElementById('annotationMode4');
        const mode4Header = document.getElementById('mode4Header');
        const mermaidDiv = document.getElementById('mermaidDiv');
        const tokenRelationsTableBody = document.getElementById('tokenRelationsTableBody');
        const mode4Status = document.getElementById('mode4Status');

        const SYNTACTIC_TYPES = ["independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle"];
        const SEMANTIC_TYPES = ["transitive", "intransitive", "linking"];
        const TOKEN_RELATION_VALUES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];
        const ASYNDETON_NODE_ID = 0;
        const ASYNDETON_NODE_TEXT = "asyndeton";
        const ASYNDETON_NODE_URN = "internal:asyndeton_node";
        const INDENTATION_UNIT_EM = 1.5;


        SYNTACTIC_TYPES.forEach(type => newVuSyntacticTypeSelect.appendChild(new Option(type, type)));
        SEMANTIC_TYPES.forEach(type => newVuSemanticTypeSelect.appendChild(new Option(type, type)));

        loadButton.addEventListener('click', loadCEXData);
        sentenceDropdown.addEventListener('change', handleSentenceChange);
        asyndetonCheckbox.addEventListener('change', handleAsyndetonChange);
        downloadAnnotationsButton.addEventListener('click', handleDownloadAnnotations); 
        addVerbalUnitBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.remove('hidden');
            addVerbalUnitBtn.classList.add('hidden');
            newVuSyntacticTypeSelect.selectedIndex = 0;
            newVuSemanticTypeSelect.selectedIndex = 0;
            newVuDepthInput.value = "0";
        });
        confirmNewVuBtn.addEventListener('click', handleConfirmVerbalUnit);
        cancelNewVuBtn.addEventListener('click', () => {
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        });
        verbalUnitSelectForAssignment.addEventListener('change', handleVerbalUnitSelectionForAssignment);

        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? 'red' : '#555';
        }

        function getCurrentSentenceAnnotation() {
            if (!currentSentenceURN) return null;
            if (!annotations[currentSentenceURN]) {
                annotations[currentSentenceURN] = {
                    asyndeton: null,
                    connectingWordURN: null,
                    verbalUnits: [],
                    tokenRelations: {} 
                };
            }
            if (!annotations[currentSentenceURN].tokenRelations) {
                 annotations[currentSentenceURN].tokenRelations = {};
            }
            return annotations[currentSentenceURN];
        }

        function generateRandomColor() {
            const r = Math.floor(Math.random() * 200);
            const g = Math.floor(Math.random() * 200);
            const b = Math.floor(Math.random() * 200);
            return `rgba(${r},${g},${b},0.5)`;
        }
        
        function loadCEXData() {
            const url = cexUrlInput.value.trim();
            if (!url) { updateStatus('Please enter a CEX URL.', true); return; }
            updateStatus('Loading CEX data...');
            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    updateStatus('CEX data loaded. Processing...');
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) { updateStatus('No "ctsdata" block found in the CEX file.', true); return; }
                    const ctsLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    processCTSData(ctsLines);
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    updateStatus(`Failed to load from URL: ${error.message}`, true);
                });
        }

        function processCTSData(ctsLines) {
            try {
                allTokens = greeklib.tokenize(ctsLines);
                const sentenceURNs = greeklib.sentences(ctsLines);

                sentenceDropdown.innerHTML = '<option value="">-- Select a sentence --</option>';
                sentenceUrnMap = {}; 
                sentenceURNs.forEach((urn, index) => {
                    sentenceDropdown.appendChild(new Option(urn, urn));
                    sentenceUrnMap[urn] = index + 1; 
                });

                sentenceSelectorDiv.classList.remove('hidden');
                // Keep download area hidden initially, will be shown by checkAndEnableMode4
                downloadAreaDiv.classList.add('hidden'); 
                selectedSentenceIndexDisplay.textContent = ''; 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div].forEach(el => el.classList.add('hidden'));
                updateStatus(`Found ${allTokens.length} tokens and ${sentenceURNs.length} sentences. Please select a sentence.`);
            } catch (error) {
                console.error('Error processing CTS data:', error);
                updateStatus(`Error processing CTS data: ${error.message}`, true);
            }
        }

        function handleSentenceChange() {
            currentSentenceURN = sentenceDropdown.value;
            currentSelectedVerbalUnitIndex = -1; 

            if (!currentSentenceURN) { 
                [sentenceDisplayAreaDiv, annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div, downloadAreaDiv].forEach(el => el.classList.add('hidden'));
                sentenceDisplay.innerHTML = '';
                currentSentenceTokens = [];
                selectedSentenceIndexDisplay.textContent = ''; 
                return;
            }
            
            selectedSentenceIndexDisplay.textContent = `Selected sentence index: ${sentenceUrnMap[currentSentenceURN]}`;

            const currentAnn = getCurrentSentenceAnnotation(); 
            currentSentenceTokens = greeklib.tokens(currentSentenceURN, allTokens);
            
            displaySentenceTokens(); 
            sentenceDisplayAreaDiv.classList.remove('hidden'); 
            
            annotationMode1Div.classList.remove('hidden');
            asyndetonCheckbox.checked = currentAnn.asyndeton === true;
            if (currentAnn.connectingWordURN) { 
                const cwToken = currentSentenceTokens.find(t => t.urn === currentAnn.connectingWordURN && t.type === 'lexical');
                if (cwToken) {
                    ensureTokenRelationEntry(currentAnn, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }
            
            updateMode1StateAndProceed();
            checkAndShowVerbalUnitTokenGrouping(); 
        }
        
        function displaySentenceTokens() {
            sentenceDisplay.innerHTML = '';
            const currentAnn = getCurrentSentenceAnnotation();

            for (let i = 0; i < currentSentenceTokens.length; i++) {
                const token = currentSentenceTokens[i];
                const tokenOuterSpan = document.createElement('span');
                const tokenTextSpan = document.createElement('span');
                tokenTextSpan.textContent = token.text;

                if (token.type === 'lexical') {
                    tokenTextSpan.classList.add('lexical-token');
                    tokenTextSpan.dataset.urn = token.urn;
                    tokenTextSpan.dataset.sequence = token.sequence; 
                    tokenTextSpan.onclick = () => handleLexicalTokenClick(token.urn, token.sequence);

                    tokenTextSpan.classList.remove('connecting-word-highlight');
                    tokenTextSpan.style.backgroundImage = 'none';

                    if (currentAnn) {
                        if (token.urn === currentAnn.connectingWordURN) {
                            tokenTextSpan.classList.add('connecting-word-highlight'); 
                        }
                        if (currentAnn.verbalUnits) {
                            for (const vu of currentAnn.verbalUnits) {
                                if (vu.assignedTokenURNs.includes(token.urn)) {
                                    tokenTextSpan.style.backgroundImage = `linear-gradient(${vu.color}, ${vu.color})`;
                                    tokenTextSpan.style.backgroundRepeat = 'no-repeat'; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    tokenOuterSpan.appendChild(sup);

                    const nextToken = (i + 1 < currentSentenceTokens.length) ? currentSentenceTokens[i + 1] : null;
                    if (!nextToken || nextToken.type !== 'punctuation') {
                        tokenOuterSpan.appendChild(document.createTextNode(' '));
                    }
                } else if (token.type === 'punctuation') {
                    tokenTextSpan.classList.add('punctuation-token');
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' '));
                } else {
                    tokenOuterSpan.appendChild(tokenTextSpan);
                    tokenOuterSpan.appendChild(document.createTextNode(' ')); 
                }
                sentenceDisplay.appendChild(tokenOuterSpan);
            }
        }

        function handleAsyndetonChange() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            
            const wasAsyndeton = ann.asyndeton;
            ann.asyndeton = asyndetonCheckbox.checked;

            if (ann.asyndeton) {
                ann.connectingWordURN = null; 
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            } else { 
                if (wasAsyndeton) { 
                    if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                        delete ann.tokenRelations[ASYNDETON_NODE_ID];
                    }
                    for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) {
                            rel.node1Sequence = null;
                            rel.node1Rel = null;
                        }
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) {
                            rel.node2Sequence = null;
                            rel.node2Rel = null;
                        }
                    }
                }
            }
            displaySentenceTokens(); 
            updateMode1StateAndProceed(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function ensureTokenRelationEntry(ann, tokenSequence, tokenText, tokenUrn, tokenType) {
            if (!ann.tokenRelations) {
                ann.tokenRelations = {};
            }
            if (!ann.tokenRelations[tokenSequence]) {
                ann.tokenRelations[tokenSequence] = {
                    tokenText: tokenText,
                    originalUrn: tokenUrn, 
                    originalType: tokenType, 
                    node1Sequence: null, node1Rel: null,
                    node2Sequence: null, node2Rel: null
                };
            } else {
                ann.tokenRelations[tokenSequence].tokenText = tokenText;
                ann.tokenRelations[tokenSequence].originalUrn = tokenUrn;
                ann.tokenRelations[tokenSequence].originalType = tokenType;
            }
        }

        function handleLexicalTokenClick(urn, sequence) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const clickedTokenObject = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
            if (!clickedTokenObject) return; 

            let mode1Pending = (ann.asyndeton === null || ann.asyndeton === false) && !ann.connectingWordURN;
            if (annotationMode1Div.classList.contains('hidden')) mode1Pending = false;


            if (mode1Pending && !asyndetonCheckbox.checked) {
                ann.connectingWordURN = urn;
                ann.asyndeton = false; 
                asyndetonCheckbox.checked = false; 
                if (ann.tokenRelations && ann.tokenRelations[ASYNDETON_NODE_ID]) {
                    delete ann.tokenRelations[ASYNDETON_NODE_ID];
                     for (const seq in ann.tokenRelations) {
                        const rel = ann.tokenRelations[seq];
                        if (rel.node1Sequence === ASYNDETON_NODE_ID) { rel.node1Sequence = null; rel.node1Rel = null;}
                        if (rel.node2Sequence === ASYNDETON_NODE_ID) { rel.node2Sequence = null; rel.node2Rel = null;}
                    }
                }
                ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                displaySentenceTokens();
                updateMode1StateAndProceed();
                return; 
            }

            if (!annotationMode3Div.classList.contains('hidden') && currentSelectedVerbalUnitIndex !== -1) {
                const currentVU = ann.verbalUnits[currentSelectedVerbalUnitIndex];
                
                for (let i = 0; i < ann.verbalUnits.length; i++) {
                    if (i === currentSelectedVerbalUnitIndex) continue; 
                    const otherVU = ann.verbalUnits[i];
                    const tokenIndexInOtherVU = otherVU.assignedTokenURNs.indexOf(urn);
                    if (tokenIndexInOtherVU > -1) {
                        otherVU.assignedTokenURNs.splice(tokenIndexInOtherVU, 1);
                    }
                }

                const tokenIndexInCurrentVU = currentVU.assignedTokenURNs.indexOf(urn);
                if (tokenIndexInCurrentVU > -1) {
                    currentVU.assignedTokenURNs.splice(tokenIndexInCurrentVU, 1);
                } else {
                    currentVU.assignedTokenURNs.push(urn);
                    ensureTokenRelationEntry(ann, sequence, clickedTokenObject.text, clickedTokenObject.urn, clickedTokenObject.type);
                }
                
                renderVerbalUnitsTable(); 
                displaySentenceTokens(); 
                checkAndEnableMode4(); 
                checkAndShowVerbalUnitTokenGrouping();
            }
        }
        
        function updateMode1StateAndProceed() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                [annotationMode1Div, annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div, downloadAreaDiv].forEach(el => el.classList.add('hidden'));
                mode1CompletionStatus.textContent = '';
                return;
            }

            annotationMode1Div.classList.remove('hidden');
            let mode1Completed = (ann.asyndeton === true) || (ann.asyndeton === false && ann.connectingWordURN !== null);

            if (ann.asyndeton === true) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Asyndeton) complete.";
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal"); 
            } else if (ann.asyndeton === false && ann.connectingWordURN) {
                mode1Instruction.classList.add('hidden');
                mode1CompletionStatus.textContent = "Mode 1 (Connecting Word) complete.";
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if(cwToken) ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);

            } else { 
                asyndetonCheckbox.checked = false; 
                ann.asyndeton = false; 
                mode1Instruction.classList.remove('hidden');
                mode1CompletionStatus.textContent = "Mode 1 pending: Complete selection or check asyndeton.";
            }

            if (mode1Completed) {
                initializeMode2UI();
            } else {
                [annotationMode2Div, verbalUnitTokenGroupingArea, 
                 annotationMode3Div, annotationMode4Div, downloadAreaDiv].forEach(el => el.classList.add('hidden'));
                 verbalUnitTokenGroupingDisplay.innerHTML = ''; 
            }
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function initializeMode2UI() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;
            annotationMode2Div.classList.remove('hidden');
            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function renderVerbalUnitsTable() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitsTableBody.innerHTML = ''; 

            if (!ann || !ann.verbalUnits) return;

            ann.verbalUnits.forEach((unit, index) => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = unit.syntacticType;
                row.insertCell().textContent = unit.semanticType;
                row.insertCell().textContent = unit.depth;
                row.insertCell().textContent = unit.assignedTokenURNs.length;
                
                const actionsCell = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => handleDeleteVerbalUnit(index);
                actionsCell.appendChild(deleteButton);
            });
        }

        function handleConfirmVerbalUnit() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) return;

            const syntacticType = newVuSyntacticTypeSelect.value;
            const semanticType = newVuSemanticTypeSelect.value;
            const depth = parseInt(newVuDepthInput.value, 10);

            if (isNaN(depth) || depth < 0) { alert("Depth must be a non-negative integer."); return; }
            
            ann.verbalUnits.push({ 
                id: Date.now(), 
                syntacticType, 
                semanticType, 
                depth,
                color: generateRandomColor(),
                assignedTokenURNs: [] 
            });
            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            checkAndShowVerbalUnitTokenGrouping();

            newVerbalUnitForm.classList.add('hidden');
            addVerbalUnitBtn.classList.remove('hidden');
        }

        function handleDeleteVerbalUnit(index) {
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !ann.verbalUnits || index < 0 || index >= ann.verbalUnits.length) return;
            
            ann.verbalUnits.splice(index, 1);
            
            if (currentSelectedVerbalUnitIndex === index) {
                currentSelectedVerbalUnitIndex = -1; 
            } else if (currentSelectedVerbalUnitIndex > index) {
                currentSelectedVerbalUnitIndex--; 
            }

            renderVerbalUnitsTable();
            checkAndEnableMode3(); 
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function checkAndEnableMode3() {
            const ann = getCurrentSentenceAnnotation();
            if (ann && ann.verbalUnits && ann.verbalUnits.length > 0) {
                annotationMode3Div.classList.remove('hidden');
                populateVerbalUnitSelectForAssignment();
                mode3Status.textContent = "Select a verbal unit to assign tokens.";
                
                if (currentSelectedVerbalUnitIndex === -1 || currentSelectedVerbalUnitIndex >= ann.verbalUnits.length) {
                     currentSelectedVerbalUnitIndex = ann.verbalUnits.length > 0 ? 0 : -1;
                }
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else {
                annotationMode3Div.classList.add('hidden');
                mode3Status.textContent = "";
                currentSelectedVerbalUnitIndex = -1;
            }
            displaySentenceTokens(); 
            checkAndEnableMode4(); 
            checkAndShowVerbalUnitTokenGrouping();
        }

        function populateVerbalUnitSelectForAssignment() {
            const ann = getCurrentSentenceAnnotation();
            verbalUnitSelectForAssignment.innerHTML = '<option value="-1">-- Select Verbal Unit --</option>';
            if (ann && ann.verbalUnits) {
                ann.verbalUnits.forEach((vu, index) => {
                    const optionText = `VU ${index + 1}: ${vu.syntacticType} (Depth ${vu.depth})`;
                    verbalUnitSelectForAssignment.appendChild(new Option(optionText, index));
                });
            }
            if (currentSelectedVerbalUnitIndex !== -1 && currentSelectedVerbalUnitIndex < (ann ? ann.verbalUnits.length : 0)) {
                verbalUnitSelectForAssignment.value = currentSelectedVerbalUnitIndex;
            } else if (ann && ann.verbalUnits.length > 0) {
                 verbalUnitSelectForAssignment.value = "0";
                 currentSelectedVerbalUnitIndex = 0;
            } else {
                 currentSelectedVerbalUnitIndex = -1;
            }
        }

        function handleVerbalUnitSelectionForAssignment() {
            currentSelectedVerbalUnitIndex = parseInt(verbalUnitSelectForAssignment.value, 10);
        }

        function findVerbalUnitForToken(tokenURN, verbalUnits) {
            if (!verbalUnits) return null;
            for (const vu of verbalUnits) {
                if (vu.assignedTokenURNs.includes(tokenURN)) return vu;
            }
            return null;
        }

        function renderVerbalUnitTokenGrouping() {
            verbalUnitTokenGroupingDisplay.innerHTML = '';
            const ann = getCurrentSentenceAnnotation();
            if (!ann || !currentSentenceTokens || currentSentenceTokens.length === 0) return;

            let currentLineDiv = null;
            let previousTokenVU_forGrouping = null; // Use a different variable name to avoid conflict

            const sortedTokens = [...currentSentenceTokens].sort((a, b) => a.sequence - b.sequence);

            for (const token of sortedTokens) {
                if (token.type !== 'lexical') continue;
                // Skip the connector token for this specific display
                if (ann.connectingWordURN && token.urn === ann.connectingWordURN) continue;

                const currentTokenVU = findVerbalUnitForToken(token.urn, ann.verbalUnits);

                if (currentTokenVU) {
                    if (!currentLineDiv || previousTokenVU_forGrouping !== currentTokenVU) {
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.style.paddingLeft = (currentTokenVU.depth * INDENTATION_UNIT_EM) + 'em';
                        verbalUnitTokenGroupingDisplay.appendChild(currentLineDiv);
                    } else {
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(document.createTextNode(token.text));
                    previousTokenVU_forGrouping = currentTokenVU;
                } else {
                    // If a token is not in any VU (and not the connector), it resets the context
                    previousTokenVU_forGrouping = null; 
                    currentLineDiv = null; 
                }
            }
        }

        function checkAndShowVerbalUnitTokenGrouping() {
            const ann = getCurrentSentenceAnnotation();
            const mode2Visible = !annotationMode2Div.classList.contains('hidden');
            let hasAssignedTokens = false;

            if (ann && ann.verbalUnits) {
                for (const vu of ann.verbalUnits) {
                    if (vu.assignedTokenURNs.length > 0) {
                        hasAssignedTokens = true;
                        break;
                    }
                }
            }

            if (mode2Visible && hasAssignedTokens) {
                verbalUnitTokenGroupingArea.classList.remove('hidden');
                renderVerbalUnitTokenGrouping();
            } else {
                verbalUnitTokenGroupingArea.classList.add('hidden');
                verbalUnitTokenGroupingDisplay.innerHTML = '';
            }
        }


        function getMode4RelevantTokens(ann) {
            const relevantTokensData = []; 
            const includedSequences = new Set();

            if (!ann) return relevantTokensData;

            if (ann.asyndeton === true) {
                relevantTokensData.push({ sequence: ASYNDETON_NODE_ID, text: ASYNDETON_NODE_TEXT, urn: ASYNDETON_NODE_URN, type: "internal" });
                includedSequences.add(ASYNDETON_NODE_ID);
                ensureTokenRelationEntry(ann, ASYNDETON_NODE_ID, ASYNDETON_NODE_TEXT, ASYNDETON_NODE_URN, "internal");
            }

            if (ann.connectingWordURN) {
                const cwToken = currentSentenceTokens.find(t => t.urn === ann.connectingWordURN && t.type === 'lexical');
                if (cwToken && !includedSequences.has(cwToken.sequence)) {
                    relevantTokensData.push({ sequence: cwToken.sequence, text: cwToken.text, urn: cwToken.urn, type: cwToken.type });
                    includedSequences.add(cwToken.sequence);
                    ensureTokenRelationEntry(ann, cwToken.sequence, cwToken.text, cwToken.urn, cwToken.type);
                }
            }

            if (ann.verbalUnits) {
                ann.verbalUnits.forEach(vu => {
                    vu.assignedTokenURNs.forEach(urn => {
                        const token = currentSentenceTokens.find(t => t.urn === urn && t.type === 'lexical');
                        if (token && !includedSequences.has(token.sequence)) {
                            relevantTokensData.push({ sequence: token.sequence, text: token.text, urn: token.urn, type: token.type });
                            includedSequences.add(token.sequence);
                            ensureTokenRelationEntry(ann, token.sequence, token.text, token.urn, token.type);
                        }
                    });
                });
            }
            relevantTokensData.sort((a, b) => {
                if (a.sequence === ASYNDETON_NODE_ID) return -1;
                if (b.sequence === ASYNDETON_NODE_ID) return 1;
                return a.sequence - b.sequence;
            });
            return relevantTokensData;
        }

        function checkAndEnableMode4() {
            const ann = getCurrentSentenceAnnotation();
            if (!ann) {
                annotationMode4Div.classList.add('hidden'); 
                downloadAreaDiv.classList.add('hidden'); // Also hide download if no sentence
                return;
            }

            const relevantTokens = getMode4RelevantTokens(ann);
            const mode4Threshold = (ann.asyndeton === true && relevantTokens.length >=1) || relevantTokens.length > 1;

            let hasAnyRelations = false;
            if (ann.tokenRelations) {
                for (const seq in ann.tokenRelations) {
                    const rel = ann.tokenRelations[seq];
                    if (rel.node1Sequence !== null || rel.node2Sequence !== null) {
                        hasAnyRelations = true;
                        break;
                    }
                }
            }

            if (mode4Threshold) { 
                annotationMode4Div.classList.remove('hidden');
                mode4Header.textContent = `Annotation Mode 4: Token Relations (Sentence Global)`;
                
                populateTokenRelationsTable(relevantTokens, ann.tokenRelations);
                renderMermaidGraph(relevantTokens, ann.tokenRelations);
                mode4Status.textContent = "";
                // Show download only if mode 4 is active AND there are relations
                if (hasAnyRelations) {
                    downloadAreaDiv.classList.remove('hidden');
                } else {
                    downloadAreaDiv.classList.add('hidden');
                }
            } else {
                annotationMode4Div.classList.add('hidden');
                downloadAreaDiv.classList.add('hidden');
                mode4Status.textContent = "Mode 4 requires at least 2 tokens or an active asyndeton node.";
                mermaidDiv.innerHTML = ""; 
            }
        }

        function populateTokenRelationsTable(relevantTokens, globalRelations) {
            tokenRelationsTableBody.innerHTML = '';
            const validTokenSequencesInTable = new Set(relevantTokens.map(t => t.sequence));

            relevantTokens.forEach(token => {
                const refSeq = token.sequence;
                if (!globalRelations[refSeq]) {
                     ensureTokenRelationEntry(getCurrentSentenceAnnotation(), refSeq, token.text, token.urn, token.type);
                }
                const relationData = globalRelations[refSeq];

                const row = tokenRelationsTableBody.insertRow();
                row.insertCell().textContent = refSeq;
                row.insertCell().textContent = token.text; 

                const createNumberInput = (currentValue, key, relData) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = currentValue !== null && currentValue !== undefined ? currentValue : '';
                    input.onchange = (e) => {
                        const val = e.target.value === '' ? null : parseInt(e.target.value, 10);
                        if (val !== null && !validTokenSequencesInTable.has(val)) {
                            alert(`Invalid Node ID: ${val}. Must be a reference of a token (or ${ASYNDETON_NODE_ID} for asyndeton) listed in this table.`);
                            e.target.value = relData[key] !== null ? relData[key] : ''; 
                            return;
                        }
                        relData[key] = val;
                        if (val === null) { 
                            if (key === 'node1Sequence') relData.node1Rel = null;
                            if (key === 'node2Sequence') relData.node2Rel = null;
                            // No need to repopulate table for clearing, just re-render graph
                        }
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                        checkAndEnableMode4(); // Re-check download visibility
                    };
                    return input;
                };

                const createRelationSelect = (currentValue, key, relData) => {
                    const select = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = ""; 
                    defaultOption.textContent = "-- Select Relation --";
                    select.appendChild(defaultOption);

                    TOKEN_RELATION_VALUES.forEach(val => {
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = val;
                        select.appendChild(option);
                    });

                    select.value = currentValue || ""; 
                    select.onchange = (e) => {
                        relData[key] = e.target.value || null; 
                        renderMermaidGraph(getMode4RelevantTokens(getCurrentSentenceAnnotation()), globalRelations);
                        checkAndEnableMode4(); // Re-check download visibility
                    };
                    return select;
                };

                row.insertCell().appendChild(createNumberInput(relationData.node1Sequence, 'node1Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node1Rel, 'node1Rel', relationData));
                row.insertCell().appendChild(createNumberInput(relationData.node2Sequence, 'node2Sequence', relationData));
                row.insertCell().appendChild(createRelationSelect(relationData.node2Rel, 'node2Rel', relationData));
            });
        }
        
        async function renderMermaidGraph(relevantTokens, globalRelations) {
            let mermaidString = 'graph BT\n'; 
            const edges = [];
            const tokenTextMap = {};
            relevantTokens.forEach(t => tokenTextMap[t.sequence] = t.text);

            for (const refSeqStr in globalRelations) {
                if (!tokenTextMap.hasOwnProperty(refSeqStr)) continue; 

                const refSeq = parseInt(refSeqStr, 10);
                const relation = globalRelations[refSeq];
                const refTokenText = tokenTextMap[refSeq];

                const addEdge = (targetSeq, relText) => {
                    if (targetSeq !== null && relText && tokenTextMap.hasOwnProperty(targetSeq)) {
                        const targetTokenText = tokenTextMap[targetSeq];
                        edges.push(`    ${refSeq}["${escapeMermaidLabel(refTokenText)}"] -- "${escapeMermaidLabel(relText)}" --> ${targetSeq}["${escapeMermaidLabel(targetTokenText)}"]`);
                    }
                };
                addEdge(relation.node1Sequence, relation.node1Rel);
                addEdge(relation.node2Sequence, relation.node2Rel);
            }
            
            if (edges.length === 0) {
                mermaidDiv.innerHTML = "No relations defined among the current set of tokens.";
                return;
            }

            mermaidString += edges.join('\n');
            
            try {
                mermaidDiv.innerHTML = ''; 
                const { svg, bindFunctions } = await mermaid.render('graphSvg-' + Date.now(), mermaidString); 
                mermaidDiv.innerHTML = svg;
                if (bindFunctions) bindFunctions(mermaidDiv);
            } catch (e) {
                console.error("Mermaid rendering error:", e, "\nGraph string:\n", mermaidString);
                mermaidDiv.innerHTML = `Error rendering graph: ${e.message}.<br><pre>${mermaidString.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
            }
        }

        function escapeMermaidLabel(text) {
            if (typeof text !== 'string') text = String(text);
            return text.replace(/"/g, '#quot;').replace(/;/g, '#59;'); 
        }

        function handleDownloadAnnotations() {
            let output = "";

            const sentencesHeader = "sentence|sequence|connector";
            const sentencesData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    const sentenceMenuIndex = sentenceUrnMap[sentenceUrn] || ''; 
                    const connectorUrn = ann.asyndeton ? '' : (ann.connectingWordURN || '');
                    sentencesData.push(`${sentenceUrn}|${sentenceMenuIndex}|${connectorUrn}`);
                }
            }
            if (sentencesData.length > 0) {
                 output += "#!sentences\n";
                 output += sentencesHeader + "\n";
                 output += sentencesData.join("\n") + "\n\n";
            }

            const verbalUnitsHeader = "vuid|syntactic_type|semantic_type|depth|sentence";
            const verbalUnitsData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.verbalUnits) {
                        ann.verbalUnits.forEach(vu => {
                            verbalUnitsData.push(`${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${sentenceUrn}`);
                        });
                    }
                }
            }
             if (verbalUnitsData.length > 0) {
                output += "#!verbal_units\n";
                output += verbalUnitsHeader + "\n";
                output += verbalUnitsData.join("\n") + "\n\n";
            }

            const tokensHeader = "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation";
            const tokensData = [];
            for (const sentenceUrn in annotations) {
                if (annotations.hasOwnProperty(sentenceUrn)) {
                    const ann = annotations[sentenceUrn];
                    if (ann.tokenRelations) {
                        for (const refSeq in ann.tokenRelations) {
                            if (ann.tokenRelations.hasOwnProperty(refSeq)) {
                                const relData = ann.tokenRelations[refSeq];
                                
                                let assignedVuId = '';
                                if (ann.verbalUnits && relData.originalUrn !== ASYNDETON_NODE_URN) {
                                    for (const vu of ann.verbalUnits) {
                                        if (vu.assignedTokenURNs.includes(relData.originalUrn)) {
                                            assignedVuId = vu.id;
                                            break;
                                        }
                                    }
                                }

                                tokensData.push([
                                    relData.originalUrn || '',         
                                    refSeq,                            
                                    relData.originalType || '',        
                                    relData.tokenText || '',           
                                    assignedVuId,                      
                                    relData.node1Sequence !== null ? relData.node1Sequence : '', 
                                    relData.node1Rel || '',            
                                    relData.node2Sequence !== null ? relData.node2Sequence : '', 
                                    relData.node2Rel || ''             
                                ].join("|"));
                            }
                        }
                    }
                }
            }
            if (tokensData.length > 0) {
                output += "#!tokens\n";
                output += tokensHeader + "\n";
                output += tokensData.join("\n") + "\n";
            }
            

            if (output.trim() === "") {
                alert("No annotations to download.");
                return;
            }

            const filename = downloadFilenameInput.value.trim() || "greek_annotations.cex";
            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```