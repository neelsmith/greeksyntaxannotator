
### USER
I want to write a web app as a single HTML file using HTML, Javascript and CSS. The app will allow readers to annotate tokens in a Greek text. We'll develop it gradually. First I want to build a UI for loading and organizing the data the user will annotate. Begin by letting the user enter a URL for a citable corpus of texts. Use this as the default value:
`https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex`
  
To load a citable text corpus from a URL, I want to use the `cex.js` library. Please include it like this:
  
```<script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>```
  
Then we'll use its `loadFromUrl` function with one parameter, the user-selected URL. This will return a `Promise<CEXParser>`. When we have a parser instance, we'll use `getDelimitedData("ctsdata")` to find citable text data (CTS data) in that source. Here's an example from the library documentation of how that could work:
  
```
const parser = new CEXParser();
parser.loadFromUrl(url)
    .then(p => {
        console.log('CEX data loaded from URL!');
        console.log(p.getDelimitedData("ctsdata"));
    })
    .catch(error => console.error('Failed to load from URL:', error));
  
  
```
  
`getDelimitedData` will return a string with each line representing a citable passage of text. Please split this into an Array of strings with one entry for each line.
With the text corpus extracted, we can structure it for analysis using the `greeklib.js` library, available here:
  
`https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js`.
  
We'll first tokenize the corpus, using the array of strings as the only parameter to `greeklib.tokenize`. This will return an Array of `Token` objects. Each `Token` has four properties, `sequence` (an integer), and three string values named `urn`, `text` and `type`, which we'll use later.
  
We'll also get a list of sentence references for the corpus. Use the array of strings as the only parameter to `greeklib.sentences`. Create a menu of these references for the user to choose from.
When the user chooses one, find the tokens that belong to that sentence using the `greeklib.tokens` function with two parameters: the identifier the user has selected, and the  array of `Token`s. This will return the array of `Token`s belonging to that sentence (a subset of the complete array of `Token`s).
  
Display the sentence tokens belonging to the chosen sentence as a continuous text formatted by considering the `type` property of each token. Tokens of type `punctuation`are always followed by a space. Tokens of type `lexical` should be followed immediately by their `sequence` property formatted as superscript in silver color. This is followed by a space unless the next token is a punctuation.  Make each lexical token clickable.
  
The annotating functionality will ultimately support 4 modes of annotation. The first mode must be completed before proceding to any of the others. Offer the user a check box to mark if the sentence illustrates _asyndeton_. If the user checks yes, mode 1 is complete. Otherwise, the user should be prompted to click on one lexical token that is the _connecting word_. This word should be highlighted in the continuous display with a yellow background.
  
When the user has completed the first annotation, we'll proceed to mode 2.
  
In mode 2, the user will edit an intially empty table with three columns, representing _verbal units_. Column 1 should have the heading "Syntactic type"; column 2 should have the heading "Semantic type"; column 3 should be labelled "Depth". The user should be given an option to add a new row to the table.  The user should then be able to choose a value for "Syntactic  type" from a list with these values: "independent clause", "subordinate clause", "circumstantial participle", "attributive participle", "indirect statement with infinitive", "indirect statement with participle". For the column "Semantic type", the user should be able to choose from a list "transitive", "intransitive", "linking". For "Depth", the user should be able to enter an integer value. When the user has entered values for all 3 columns, the user should be able to confirm the values for that row and add the row to the table. The user should be able to delete rows from the table. For each verbal unit, choose a pastel color that is easily distinguished from all other selected colors.
  
Once the user confirmed one row in the verbal units table, mode 2 remains available to add new rows, but mode 3 now becomes available. The table edited in mode 2 represents _verbal units_. In mode 3, the user will assign tokens to one of the defined  verbal units. The user should be able to select from a menu of the verbal units immediately below the display of sentence tokens, then begin clicking on tokens in the display. This should assign the token to the selected verbal unit. Clicking should function as a toggle: if the token is already assigned to the selected verbal unit, clicking should remove it from the list. When a token is assigned to a verbal unit, it should be highlighted using the previously chosen color for that verbal unit.
  
Once the user has assigned more than one token to a verbal unit, mode 4 becomes available as well. In mode 4, the user edits a table defining relations among tokens in the sentence. The table should have 6 columns: labelled "Reference", "Token", "Node 1", "Node 1 relation", "Node 2" and "Node 2 relation". The table should be initialzed with one row for each lexical token in the passage, using the string value of the token as the value for the "Token" column, and the ID number as the value for the "Reference" column. These columns are not editable. The columns "Node 1" and "Node 2" are initially null, user-editable integer values. The user may enter the reference number for another token. User-entered values must refer to an integer value appearing in the table's reference column.
In editing the two columns "Node 1 Relation" and "Node 2 Relation", users should be able to choose from this list of values:
  
```
conjunction
subordinate conjunction
relative pronoun
unit verb
predicate
subject
direct object
agent
object of preposition
direct address
complementary infinitive
supplementary participle
modal particle
adverbial
attributive
article
pronoun
dative
genitive
```
  
  
The user should be able to add a new row to this table for an _implied_ token. The `Reference` value for the additional token should be a unique integer value. The `Token` column should have the value `implied`. The Do not add _implied_ tokens to the display of sentence tokens.
  
  
Above the table editor, the page should include a Mermaid visualization of a  directed graph. Use the 3 columns with integer values as the IDs for relations among nodes; use the "Token" column as the label for the node identified by the "Reference" column. Use "Node 1 relation" as the label for edge between "Reference" and "Node 1"; use "Node 2 relation" as the label for edge between "Reference" and "Node 2".  Do not include unlinked nodes in the graph. The user should be able to choose between top to bottom and right to left display of the graph.
**Example***: if a table included three rows like this:
  
| Reference | Token | Node 1 | Node 1 relation | Node 2 | Node 2 relation |
| --- | --- | ---  | --- | --- | --- |
| 12 |  ἡ | 14 | article | ||
| 13 |  αὐτὴ |  |  | ||
| 14 | τιμωρία |  |  | ||
  
  
and the user chose top to bottom display, the Mermaid graph would look like:
  
  
```mermaid
graph TB
12[" ἡ"]-- article --> 14["τιμωρία"]
```
  
The user should have an option to download the mermaid display as a PNG file.
  
The user should also have an to download the annotations data. We'll write data for sentences, verbal units, and tokens to a single plain-text file, with 3 blocks of delimited-text data.
  
The first block will begin with a labelling line `#!sentences`, followed by a pipe-delimited header line `sentence|sequence|connector`. This will be followed by one line for each annotated sentence, with three pipe-delimited columns. The first column will be the identifier for the sentence in the form used in the user menu. The second column will be the sequence number of that sentence in the menu. The third column will be an identifier for the connecting word, or empty if the sentence illustrates asyndeton. The identifier to use is the `urn` property of the `Token` object that the user chose as the connecting word.
**Example**: If the user chose a sentence identifier `urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.1-1.6.46a`, and it was the tenth sentence in the menu, then chose a token with text value `γὰρ` that was identified by the `urn` property `urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.2`, that would be represented with this line:
  
`urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.1-1.6.46a|10|urn:cts:greekLit:tlg0540.tlg001.omar_tokens:1.6.2`
  
The second block will begin with a labelling line `#!verbal_units`, then the pipe-delimited header line `vuid|syntactic_type|semantic_type|depth|sentence`, followed by one pipe-delimited line of data for each verbal unit. `vuid` is a unique id for this verbal unit; `syntactic_type`, `semantic_type`, and `depth` are the values of the columns "Syntactic type", "Semantic type",  and "Depth", respectively. `sentence` is the same ID value for the sentence that was used in the first block of sentences (and hence can be used by other applications to join verbal units and sentences)
  
The third block will begin with a labelling line  `#!tokens`, then the pipe-delimited header line `urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation`.  This will be followed by one line for each record in the user-edited table for mode 4 defining relations among nodes.  If the node is an _implied_ node, the `urn` value should be `implied`; otherwise, the value should be the value of the `urn` property of the `Token` object that was annotated. The value for `verbalunit` will be the verbal unit the token was assigned to. For implied tokens, the `verbalunit` column use the value for verbal unit of any node linked to it. **Example**: If a row in the table with reference ID `-1` had a token value of `implied` we would look for a related node that had `-1` for its "Node 1 Relation". If the first node we found with a "Node 1 Relation" of `-1` was assigned to the verbal unit `1749409472121`, we would also use `1749409472121` as the value for the verbal unit of the implied node.
  
The remaining columns will have the values of the columns "Reference", "Token", "Node 1 (ID)", "Node 1 Relation", "Node 2 (ID)", and "Node 2 Relation" from the user-edited table.
  
Could you please implement this?

### ASSISTANT
Okay, this is a comprehensive web application. I'll structure it within a single HTML file as requested. Due to the complexity and length, I'll provide the complete HTML structure with embedded CSS and JavaScript.

This will be a large single file. I'll use placeholders for some UI messages and focus on the core functionality.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        #tempMermaidRenderer { display: none; } /* For PNG generation */
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2>1. Load Corpus</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Sentence Display -->
        <h2>2. Sentence Tokens</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Annotation Modes -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 1: Asyndeton / Connecting Word -->
            <div id="mode1Section" class="mode-section">
                <h3>Mode 1: Asyndeton / Connecting Word</h3>
                <label>
                    <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
                </label>
                <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
                <p>Status: <span id="mode1Status">Pending</span></p>
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Mode 2: Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mode 3: Assign Tokens to Verbal Units -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Mode 3: Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit.</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Mode 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
                
                <h4>Mermaid Graph Visualization</h4>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <button id="downloadMermaidPngBtn">Download Graph as PNG</button>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
                <div id="tempMermaidRenderer"></div> <!-- Hidden div for mermaid PNG rendering -->
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; // Array of {urn: string, text: string (for display)}
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, // The URN used in the dropdown, might be different from token URNs base
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], // { id: string, syntacticType: string, semanticType: string, depth: number, color: string }
            tokenToVuMap: {}, // { tokenOriginalUrn: vuId }
            relations: [], // { reference: number, tokenText: string, originalTokenUrn: string ("implied" or actual URN), node1: number|null, node1Rel: string|null, node2: number|null, node2Rel: string|null }
            selectedSentenceTokens: [] // Full Token objects for the current sentence
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, // True if at least one VU is added
            mode3MinTokensForVu: false // True if any VU has >1 token assigned
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1
        const mode1Section = document.getElementById('mode1Section');
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mode 3
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const downloadMermaidPngBtn = document.getElementById('downloadMermaidPngBtn');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => renderSentenceTokens()); // Re-render to clear previous VU highlights potentially
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadMermaidPngBtn.addEventListener('click', downloadMermaidAsPng);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` // Simple display text
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); // Clear previous sentence data

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);

            // Filter tokens for the selected sentence. greeklib.tokens expects the URN and all tokens.
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            // The URN for the #!sentences block should be the one from the menu.
            // Individual token URNs will be used for connectors etc.
            // The first token's URN can give a base for the sentence if needed for other purposes,
            // but sentenceCtsUrn is the identifier for the selected passage.
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; // Fallback if no tokens
            }


            annotationModesContainer.classList.remove('hidden');
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; // Enabled when Mode 1 is complete

            initializeMode1();
            initializeMode4TableStructure(); // Prepare data structure even if hidden
            renderSentenceTokens();
            updateModeSectionsVisibility();
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            annotationModesContainer.classList.add('hidden');
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility();
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; // Store sequence for easy access
                tokenSpan.dataset.type = token.type;

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    // Highlight connecting word for Mode 1
                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    // Highlight for Mode 3 (Verbal Unit assignment)
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else {
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                // Spacing logic
                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { // other types if any
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        function handleTokenClick(token) {
            // Mode 1: Selecting connector word
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); // Re-render to show highlight
            }
            // Mode 3: Assigning token to verbal unit
            else if (modeStatus.mode1Complete && modeStatus.mode2VuAdded && token.type === 'lexical') {
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { // Toggle off
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { // Assign or re-assign
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); // Check if Mode 4 can be unlocked
                renderSentenceTokens(); // Re-render to show VU color
                updateModeSectionsVisibility(); // Potentially unlock Mode 4
                renderRelationsTable(); // To update VU assignments if visible
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); // Remove any connector highlight
            } else {
                currentAnnotation.isAsyndeton = false;
                // If already complete, changing this means user needs to pick a connector
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; // Re-open mode 1 essentially
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); // Lock subsequent modes until connector chosen
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth)) {
                alert('Depth must be an integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn // Link to the selected passage URN
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true;
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment();
            updateModeSectionsVisibility();
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); // Short ID for display
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            // Remove VU and any token assignments to it
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); // Recheck for Mode 4 unlock
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment();
            renderSentenceTokens(); // Update token highlights
            updateModeSectionsVisibility(); // Potentially lock/unlock modes
        }

        function updateVuSelectorForAssignment() {
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false;
            } else {
                vuSelectorForAssignment.disabled = true;
            }
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function checkMinTokensForVU() {
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Mode 4 available." : 
                "Assign multiple tokens to a single VU to enable Mode 4.";
            updateModeSectionsVisibility();
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') {
                    currentAnnotation.relations.push({
                        reference: token.sequence, // Use sequence as reference
                        tokenText: token.text,
                        originalTokenUrn: token.urn, // Store original URN
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; // Reset for new sentence
            renderRelationsTable();
            renderMermaidGraph();
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable();
            renderMermaidGraph();
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                // Node 1 ID
                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; // Revert
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                };
                node1Cell.appendChild(node1Input);

                // Node 1 Relation
                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                // Node 2 ID
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; // Revert
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                };
                node2Cell.appendChild(node2Input);

                // Node 2 Relation
                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                });
                node2RelCell.appendChild(node2RelSelect);

                // Actions
                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        // Also remove any links pointing to this implied token
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable();
                        renderMermaidGraph();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { // Only render if Mode 4 is active
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Mode 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); // Escape quotes for mermaid label

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            // "Do not include unlinked nodes in the graph."
            // The above loop only adds edges, implicitly only including linked nodes.
            // If we needed to explicitly add node definitions for nodes that are only targets,
            // we would iterate nodesInGraph and add `id["label"]` lines if not already defined.
            // But Mermaid typically handles this. The current logic effectively achieves this.

            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; // Clear previous
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        async function downloadMermaidAsPng() {
            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            // Rebuild definition for download to ensure it's current
             currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;');
                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                     if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                     const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                    }
                }
            });

            if (mermaidDefinition === `graph ${orientation}\n`) {
                alert("No graph data to download.");
                return;
            }
            
            try {
                const tempRenderer = document.getElementById('tempMermaidRenderer');
                const { svg } = await mermaid.render('tempgraph-' + Date.now(), mermaidDefinition);
                
                const img = new Image();
                const svgBlob = new Blob([svg], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    // Add some padding or scale for better rendering if needed
                    canvas.width = img.width * 1.1; 
                    canvas.height = img.height * 1.1;
                    const ctx = canvas.getContext('2d');
                    // Fill background for transparency issues if any (SVG might be transparent)
                    ctx.fillStyle = 'white'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, (canvas.width - img.width)/2, (canvas.height - img.height)/2); // Center it
                    
                    const pngUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = pngUrl;
                    a.download = 'mermaid_graph.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
                img.onerror = (e) => {
                    console.error("Error loading SVG into image for PNG conversion:", e);
                    alert("Failed to convert graph to PNG.");
                    URL.revokeObjectURL(url);
                }
                img.src = url;

            } catch (e) {
                console.error("Error preparing PNG download:", e);
                alert("Failed to generate PNG for download.");
            }
        }

        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            mode1Section.classList.toggle('hidden', !currentAnnotation.sentenceUrn);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            mode3Section.classList.toggle('hidden', !modeStatus.mode2VuAdded);
            mode4Section.classList.toggle('hidden', !modeStatus.mode3MinTokensForVu);
            if (modeStatus.mode3MinTokensForVu) renderMermaidGraph(); // Render graph if Mode 4 becomes visible
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Mode 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            // #!sentences block
            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            // Use currentAnnotation.sentenceCtsUrn which is the URN from the dropdown menu
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            // #!verbal_units block
            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            // #!tokens block
            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; // 'implied' or actual URN
                let tokenType = "implied"; // Default for implied
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                        // tokenText is already in rel.tokenText
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { // Implied token - find VU from a linked actual token
                    // Strategy: check if this implied token is node1 or node2 of an actual token
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    // If not found, check if this implied token links to an actual token
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            // Create download link
            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>

```

### USER
Superb! Let's make a few UI tweaks, without changing any functionality.
Please move the section labelled "Mode 1: Asyndeton / Connecting Word" immediately below the menu to select a sentence and before the section labelled "Sentence Tokens". Change its label from "Mode 1: Asyndeton / Connecting Word" to "Annotation 1: Asyndeton / Connecting Word".
  
Change the heading "Mode 2: Define Verbal Units" to "Annotation 2: Define Verbal Units".
  
Change the heading "Mode 3: Assign Tokens to Verbal Units" to "Annotation 3: Assign Tokens to Verbal Units"
  
Move the section labelled "Mermaid Graph Visualization" to come immediately before the section "Mode 4: Define Token Relations". Change the heading "Mermaid Graph Visualization"  to "Syntax Graph Visualization". Change the heading "Mode 4: Define Token Relations" to "Annotation 4: Define Token Relations".

### ASSISTANT
Okay, I've made the requested UI tweaks by adjusting the HTML structure and changing the labels. The JavaScript logic for showing/hiding these sections should adapt correctly as the element IDs are maintained.

Here's the updated HTML with the changes:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        #tempMermaidRenderer { display: none; } /* For PNG generation */
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2>1. Load Corpus</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word (Moved Here) -->
        <div id="mode1Section" class="mode-section hidden"> <!-- Initially hidden -->
            <h3>Annotation 1: Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display -->
        <h2>2. Sentence Tokens</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Annotation Modes Container (for modes 2, 3, 4 and graph) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Annotation 2: Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mode 3: Assign Tokens to Verbal Units -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Annotation 3: Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit.</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mermaid Graph Visualization (Moved Here) -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <button id="downloadMermaidPngBtn">Download Graph as PNG</button>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
                <div id="tempMermaidRenderer"></div> <!-- Hidden div for mermaid PNG rendering -->
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; // Array of {urn: string, text: string (for display)}
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        
        const mode1Section = document.getElementById('mode1Section'); // Now top-level access
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1 (elements within mode1Section)
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mode 3
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mermaid Graph (newly grouped)
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); // New wrapper
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const downloadMermaidPngBtn = document.getElementById('downloadMermaidPngBtn');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => renderSentenceTokens()); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadMermaidPngBtn.addEventListener('click', downloadMermaidAsPng);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            // Show Mode 1 and the container for other modes
            mode1Section.classList.remove('hidden'); 
            annotationModesContainer.classList.remove('hidden');
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            updateModeSectionsVisibility(); // This will correctly hide modes 2,3,4 initially
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); // Hide Mode 1
            annotationModesContainer.classList.add('hidden'); // Hide container for 2,3,4,graph
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); // Ensures internal sections are also reset to hidden
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else {
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && modeStatus.mode2VuAdded && token.type === 'lexical') {
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth)) {
                alert('Depth must be an integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true;
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment();
            updateModeSectionsVisibility();
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment();
            renderSentenceTokens(); 
            updateModeSectionsVisibility(); 
        }

        function updateVuSelectorForAssignment() {
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false;
            } else {
                vuSelectorForAssignment.disabled = true;
            }
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function checkMinTokensForVU() {
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility();
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') {
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable();
            renderMermaidGraph();
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable();
            renderMermaidGraph();
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable();
                        renderMermaidGraph();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            // Graph rendering is tied to mode3MinTokensForVu (which controls visibility of graphSection and mode4Section)
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        async function downloadMermaidAsPng() {
            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
             currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;');
                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                     if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                     const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                    }
                }
            });

            if (mermaidDefinition === `graph ${orientation}\n`) {
                alert("No graph data to download.");
                return;
            }
            
            try {
                const tempRenderer = document.getElementById('tempMermaidRenderer');
                const { svg } = await mermaid.render('tempgraph-' + Date.now(), mermaidDefinition);
                
                const img = new Image();
                const svgBlob = new Blob([svg], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width * 1.1; 
                    canvas.height = img.height * 1.1;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'white'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, (canvas.width - img.width)/2, (canvas.height - img.height)/2); 
                    
                    const pngUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = pngUrl;
                    a.download = 'syntax_graph.png'; // Updated download name
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
                img.onerror = (e) => {
                    console.error("Error loading SVG into image for PNG conversion:", e);
                    alert("Failed to convert graph to PNG.");
                    URL.revokeObjectURL(url);
                }
                img.src = url;

            } catch (e) {
                console.error("Error preparing PNG download:", e);
                alert("Failed to generate PNG for download.");
            }
        }

        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            // Mode 1 section visibility is handled by sentence selection (show) and reset (hide)
            // It's already correctly set to hidden initially in HTML.
            // And handleSentenceSelect removes 'hidden' when sentence is chosen.
            // resetAnnotationEnvironment adds 'hidden' when sentence is deselected/reset.

            // Modes within annotationModesContainer:
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            mode3Section.classList.toggle('hidden', !modeStatus.mode2VuAdded);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Excellent. Now I'd like to _remove_ the option to download the Memaid graph. (Download of annotations should remain unchanged.) Move the section labelled
"Annotation 3: Assign Tokens to Verbal Units" immediately below the display of "Sentence Tokens" and above the section "Annotation 2: Define Verbal Units".

### ASSISTANT
Okay, I've applied the requested UI changes:

1.  The "Download Graph as PNG" button and its functionality have been removed.
2.  The "Annotation 3: Assign Tokens to Verbal Units" section has been moved in the HTML structure to appear immediately after the "Sentence Tokens" display and before "Annotation 2: Define Verbal Units".

The visibility logic in JavaScript has been adjusted so that both "Annotation 2" and "Annotation 3" sections become visible once "Annotation 1" is complete. "Annotation 3" will appear, but its main control (the verbal unit selector) will remain disabled until verbal units are defined in "Annotation 2".

Here's the updated code:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        /* #tempMermaidRenderer removed as PNG download is gone */
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2>1. Load Corpus</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Annotation 1: Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display -->
        <h2>2. Sentence Tokens</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Annotation Modes Container (for modes 3, 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            
            <!-- Mode 3: Assign Tokens to Verbal Units (Moved Here) -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Annotation 3: Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit. (Define verbal units in Annotation 2 first)</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Annotation 2: Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <!-- Download button removed -->
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
                <!-- tempMermaidRenderer removed -->
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3 (Now appears before Mode 2 in HTML, but logic depends on Mode 2)
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => renderSentenceTokens()); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            // downloadMermaidPngBtn event listener removed
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else {
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            // Check mode1Complete for Mode 3 activation, and mode2VuAdded for actual usability of Mode 3
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) {
                    // This case should ideally be prevented by disabling vuSelectorForAssignment,
                    // but a direct click on a token might still happen.
                    // Guide user to define VUs first if they click a token for assignment.
                    alert("Please define Verbal Units in Annotation 2 before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth)) {
                alert('Depth must be an integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; // This is key for enabling Mode 3's selector
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); // This will enable the selector in Mode 3
            updateModeSectionsVisibility(); // Might unlock Mode 4 if conditions met via checkMinTokensForVU
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); // This will update and possibly disable Mode 3's selector
            renderSentenceTokens(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function updateVuSelectorForAssignment() { // Called when VUs change (Mode 2)
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; // Enable selector
            } else {
                vuSelectorForAssignment.disabled = true; // Disable if no VUs
            }
        }

        function checkMinTokensForVU() { // Called after token assignment in Mode 3
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility(); // This might show/hide Mode 4 and Graph
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') {
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable();
            renderMermaidGraph();
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable();
            renderMermaidGraph();
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable();
                        renderMermaidGraph();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // downloadMermaidAsPng function removed

        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            // mode1Section and annotationModesContainer visibility are handled by sentence selection.

            // Sections *within* annotationModesContainer:
            // Mode 3 (Assign Tokens) becomes visible once Mode 1 is complete.
            // Its controls (vuSelectorForAssignment) are enabled/disabled by updateVuSelectorForAssignment based on modeStatus.mode2VuAdded.
            mode3Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            // Mode 2 (Define VUs) also becomes visible once Mode 1 is complete.
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            // Graph and Mode 4 (Token Relations) become visible if Mode 3 has met its condition.
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Good. Now change the heading "Annotation 3: Assign Tokens to Verbal Units" to "Assign Tokens to Verbal Units", and the heading "Annotation 2: Define Verbal Units" to "Define Verbal Units".

### ASSISTANT
Okay, I've updated the headings for "Annotation 2" and "Annotation 3" as requested.

Here's the relevant part of the HTML structure that has changed:

From (within `annotationModesContainer`):
```html
            <!-- Mode 3: Assign Tokens to Verbal Units (Moved Here) -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Annotation 3: Assign Tokens to Verbal Units</h3>
                ...
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Annotation 2: Define Verbal Units</h3>
                ...
            </div>
```

To:
```html
            <!-- Mode 3: Assign Tokens to Verbal Units (Moved Here) -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Assign Tokens to Verbal Units</h3>
                ...
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                ...
            </div>
```

The full code with these heading changes is below:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2>1. Load Corpus</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Annotation 1: Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display -->
        <h2>2. Sentence Tokens</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Annotation Modes Container -->
        <div id="annotationModesContainer" class="hidden">
            
            <!-- Mode 3: Assign Tokens to Verbal Units -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit. (Define verbal units below first)</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => renderSentenceTokens()); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else {
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) {
                    alert("Please define Verbal Units first (below) before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth)) {
                alert('Depth must be an integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') {
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable();
            renderMermaidGraph();
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable();
            renderMermaidGraph();
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable();
                        renderMermaidGraph();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Change the label "Annotation 1: Asyndeton / Connecting Word" to "Asyndeton / Connecting Word". Change the label "Load Corpus" to "Load Corpus and Choose Sentence". Change the label "Sentence Tokens" to "Annotate Sentence".
  
Then immediately after that, let's add a further display of the `text` property of all tokens assigned to a verbal unit, as follows: if a token belongs to the same verbal unit as the preceding token, it continues on the same line. If it belongs to a different verbal unit, it begins a new line. Line beginnings should be indented according to the depth value of the verbal unit. Level 1 verbal units should be flush left; level 2 units should be indented one level further; etc. Tokens on the same line should be separated by a single white space.

### ASSISTANT
Okay, I've implemented the requested label changes and added the new "Verbal Unit Structure (Text Flow)" display.

**Summary of Changes:**

1.  **Label Updates:**
    *   "Annotation 1: Asyndeton / Connecting Word" is now "Asyndeton / Connecting Word".
    *   `<h2>1. Load Corpus</h2>` is now `<h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>`.
    *   `<h2>2. Sentence Tokens</h2>` is now `<h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>`.
2.  **New Display Section:**
    *   A new section titled "Verbal Unit Structure (Text Flow)" has been added immediately after the "Annotate Sentence" (token display) section.
    *   It displays the `text` of tokens assigned to verbal units.
    *   Tokens in the same verbal unit are on the same line, separated by a space.
    *   A new line starts for a new verbal unit.
    *   Line indentation is based on the verbal unit's `depth` property:
        *   Depth 0 or 1: Flush left (0 indents).
        *   Depth 2: 1 indent unit.
        *   Depth N (>1): (N-1) indent units.
    *   This display updates when sentence selection changes, token-to-VU assignments are modified, or verbal units are added/deleted.
    *   The new display area uses `monospace` font and `white-space: pre-wrap` for proper formatting.

Here is the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        #verbalUnitTextView { white-space: pre-wrap; line-height: 1.5em; font-family: monospace; padding: 10px; border: 1px solid #eee; background-color: #f9f9f9; min-height: 50px;}
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- New Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>Verbal Unit Structure (Text Flow)</h3>
            <div id="verbalUnitTextView">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container -->
        <div id="annotationModesContainer" class="hidden">
            
            <!-- Mode 3: Assign Tokens to Verbal Units -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit. (Define verbal units below first)</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { // When VU selection for assignment changes
                renderSentenceTokens(); // Re-render sentence tokens (no actual change needed, but good practice)
                // No need to renderVerbalUnitTextView here as assignments haven't changed yet by just selecting from dropdown
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else {
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        const indentUnits = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.style.paddingLeft = `${indentUnits * 1.5}em`; // Using 1.5em for indent unit
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                        currentLineDiv.textContent = token.text; 
                    } else {
                        currentLineDiv.textContent += ' ' + token.text; 
                    }
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) {
                    alert("Please define Verbal Units first (below) before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth)) {
                alert('Depth must be an integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') {
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable();
            renderMermaidGraph();
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable();
            renderMermaidGraph();
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val)) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable();
                        renderMermaidGraph();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
In the section "Verbal Unit Structure (Text Flow)", do not use a monospace font. Achieve the correct level of indentation using CSS. In both this section and in the display labelled "Annotate Sentence", please add text decoration to tokens based on the "Node 1 Relation" column of the table in the section "Annotation 4: Define Token Relations" as follows: any tokens that have a value of `unit verb` should have a black bounding rectangle; any tokens with value of `subject` should be underlined; any tokens with a value `direct object` or `predicate` should have both an underline and overline.

### ASSISTANT
Okay, I've implemented these significant UI and styling changes.

**Summary of Key Modifications:**

1.  **Label Changes:**
    *   "Annotation 1: Asyndeton / Connecting Word" -> "Asyndeton / Connecting Word"
    *   "1. Load Corpus" -> "1. Load Corpus and Choose Sentence"
    *   "2. Sentence Tokens" -> "2. Annotate Sentence"

2.  **"Verbal Unit Structure (Text Flow)" Display:**
    *   Font changed from monospace to the default body font.
    *   Indentation is now achieved using CSS classes (`vu-line-indent-0`, `vu-line-indent-1`, etc.) applied to line `div`s, based on the verbal unit's depth. `depth: 1` is flush left.
    *   Tokens within this display are now individual `<span>` elements to allow for specific styling.

3.  **Token Decorations (Applied in "Annotate Sentence" and "Verbal Unit Structure (Text Flow)"):**
    *   A new helper function `getTokenStylingClasses(tokenSequence)` determines decoration classes based on the `Node 1 Relation` in the "Annotation 4" table for that token's sequence number.
    *   **`unit verb`**: Tokens get a `node-rel-unit-verb` class (black border).
    *   **`subject`**: Tokens get a `node-rel-subject` class (underline).
    *   **`direct object` or `predicate`**: Tokens get a `node-rel-dobj-pred` class (underline and overline).
    *   These decorations are applied dynamically and update when sentence selection changes, relations in Annotation 4 are modified, or token-to-VU assignments change.

**Updated CSS includes:**

```css
#verbalUnitTextView { /* font-family: monospace removed */ white-space: pre-wrap; line-height: 1.5em; padding: 10px; border: 1px solid #eee; background-color: #f9f9f9; min-height: 50px;}
.vu-line { /* You can add common styling for lines here if needed */ }
.vu-line-indent-0 { margin-left: 0; }
.vu-line-indent-1 { margin-left: 1.5em; }
.vu-line-indent-2 { margin-left: 3em; }
.vu-line-indent-3 { margin-left: 4.5em; }
/* Add more .vu-line-indent-N classes if deeper nesting is common */

/* Token decoration styles */
.node-rel-unit-verb { 
    border: 1px solid black; 
    padding: 0 1px; /* Minimal padding so it doesn't expand too much */
    display: inline-block; /* Essential for border to wrap content correctly */
    line-height: normal; /* May need to adjust based on surrounding line-height */
    border-radius: 2px; /* Slight rounding for aesthetics */
}
.node-rel-subject { text-decoration: underline; }
.node-rel-dobj-pred { text-decoration: underline overline; }
```

Here is the complete updated code:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; /* Increased slightly for better readability with decorations */
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
        }
        .vu-line { /* Base class for lines in verbal unit text view if common styles needed */ }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } /* Added a few more for potential deeper nesting */
        .vu-line-indent-5 { margin-left: 7.5em; }

        /* Token decoration styles */
        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; /* Keep padding minimal */
            display: inline-block; 
            line-height: normal; /* Reset line height for the bordered element */
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- New Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>Verbal Unit Structure (Text Flow)</h3>
            <div id="verbalUnitTextView">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container -->
        <div id="annotationModesContainer" class="hidden">
            
            <!-- Mode 3: Assign Tokens to Verbal Units -->
            <div id="mode3Section" class="mode-section hidden">
                <h3>Assign Tokens to Verbal Units</h3>
                <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
                <select id="vuSelectorForAssignment" disabled></select>
                <p>Click on lexical tokens in the sentence display above to assign/unassign them to the selected verbal unit. (Define verbal units below first)</p>
                <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
            </div>

            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer');
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3
        const mode3Section = document.getElementById('mode3Section');
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        // Helper function for token decoration classes
        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                // Apply Node 1 Relation styling
                if (token.type === 'lexical') {
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { // Punctuation tokens also get styling if they were part of relations (unlikely but to be safe)
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    // Apply Node 1 Relation styling
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) {
                    alert("Please define Verbal Units first (below) before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { // Depth should be non-negative
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                // Only add lexical tokens to the relations table initially
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); // This will call renderMermaidGraph and also the token display updates
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) { // Allow self-reference if needed, but check others
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')}`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); // Re-render table itself
                        renderMermaidGraph();   // And dependent displays
                        renderSentenceTokens(); 
                        renderVerbalUnitTextView();
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            // Initial render of token displays after table structure is built or changed
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); // Ensure graph is also up to date
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Great! Change the label "Verbal Unit Structure (Text Flow)" to "Verbal Unit Structure". Move the section labelled "Assign Tokens to Verbal Units"  immediately below the heading "Annotate Sentence" and above the display of sentence tokens.

### ASSISTANT
Okay, I've made the requested label change and moved the "Assign Tokens to Verbal Units" section. I've also updated the instructional text within that section to reflect its new position relative to other elements.

**Key Changes:**

1.  **Label Change:**
    *   The heading "Verbal Unit Structure (Text Flow)" is now "Verbal Unit Structure".
2.  **Section Move:**
    *   The section `<div id="mode3Section" ...>` ("Assign Tokens to Verbal Units") has been moved from inside `annotationModesContainer` to be directly under the `<h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>` and *before* the `<div id="sentenceTokenDisplay">`.
3.  **Instructional Text Update:**
    *   The paragraph within `mode3Section` now reads: `<p>Click on lexical tokens in the sentence display (below) to assign/unassign them. Define Verbal Units (further below) to enable selection.</p>`

The JavaScript for controlling visibility of `mode3Section` (`updateModeSectionsVisibility`) already handles its display based on `modeStatus.mode1Complete`, and the enabling/disabling of its verbal unit selector (`vuSelectorForAssignment`) is correctly managed by `updateVuSelectorForAssignment` based on whether verbal units have been defined in the "Define Verbal Units" section.

Here is the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Assign Tokens to Verbal Units (Moved here) -->
        <div id="mode3Section" class="mode-section hidden">
            <h3>Assign Tokens to Verbal Units</h3>
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
            <p>Click on lexical tokens in the sentence display (below) to assign/unassign them. Define Verbal Units (further below) to enable selection.</p>
            <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>Verbal Unit Structure</h3>
            <div id="verbalUnitTextView">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); // Now top-level access
        const annotationModesContainer = document.getElementById('annotationModesContainer'); // For 2, graph, 4
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        const mode3Status = document.getElementById('mode3Status');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); // Show Mode 3 along with Mode 1
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); // Also hide Mode 3 on reset
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        // Helper function for token decoration classes
        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                // Apply Node 1 Relation styling
                if (token.type === 'lexical') { // Lexical tokens are the ones in the relations table
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    // Punctuation tokens are not typically in the relations table by sequence number in the current design
                    // If they needed styling based on some other criteria, it would go here.
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    // Apply Node 1 Relation styling if it's a lexical token (the ones in the table)
                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { // VUs defined in Mode 2
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs ---
        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
                "At least one VU has multiple tokens. Annotation 4 available." : 
                "Assign multiple tokens to a single VU to enable Annotation 4.";
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                        // No need to call other render functions here as renderRelationsTable itself will do it at the end
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            // These ensure all dependent displays are updated after table modifications.
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            // Mode 3 (Assign Tokens) is now outside annotationModesContainer.
            // Its visibility is handled directly on sentence selection and reset.
            // mode3Section.classList.toggle('hidden', !modeStatus.mode1Complete); // Already handled at higher level

            // Sections *within* annotationModesContainer:
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Now remove the heading "Assign Tokens to Verbal Units", the instructions beginning "Click on lexical tokens in the sentence display (below) to assign/unassign them. ", and the status display for that task, so that the menu to select verbal units is directly above the sentence token display.

### ASSISTANT
Okay, I've removed the specified heading, instructional paragraph, and status display from the "Assign Tokens to Verbal Units" section. This leaves the verbal unit selection dropdown directly above the sentence token display, as requested.

I've also removed the line in the JavaScript that tried to update the `textContent` of the now-deleted `mode3Status` element.

**Key HTML changes within `<div id="mode3Section" ...>`:**

**Before:**
```html
        <div id="mode3Section" class="mode-section hidden">
            <h3>Assign Tokens to Verbal Units</h3>
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
            <p>Click on lexical tokens in the sentence display (below) to assign/unassign them. Define Verbal Units (further below) to enable selection.</p>
            <p>Status: <span id="mode3Status">Pending token assignments.</span></p>
        </div>
```

**After:**
```html
        <div id="mode3Section" class="mode-section hidden">
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
            <!-- Heading, paragraph, and status paragraph removed -->
        </div>
```

**JavaScript change in `checkMinTokensForVU()`:**

Removed:
```javascript
            // mode3Status.textContent = modeStatus.mode3MinTokensForVu ? 
            //     "At least one VU has multiple tokens. Annotation 4 available." : 
            //     "Assign multiple tokens to a single VU to enable Annotation 4.";
```

The rest of the application logic remains the same.

Here is the complete updated HTML file:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        #mode3Section { padding-bottom: 5px; margin-bottom: 0; border-bottom: none; } /* Adjust padding for tighter look */
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Assign Tokens to Verbal Units -->
        <div id="mode3Section" class="mode-section hidden">
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
            <!-- Heading, paragraph, and status paragraph removed -->
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>Verbal Unit Structure</h3>
            <div id="verbalUnitTextView">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Annotation 4: Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer'); 
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        // const mode3Status = document.getElementById('mode3Status'); // Element removed
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        // Helper function for token decoration classes
        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                if (token.type === 'lexical') { 
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { 
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        // --- Mode 3: Assign Tokens to VUs (No specific functions for mode3, logic is in token click and VU updates) ---
        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            // mode3Status element is removed, so no text update here.
            // The modeStatus.mode3MinTokensForVu flag is still used by updateModeSectionsVisibility.
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once Annotation 4 is active and relations are defined.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        // --- UI State Management ---
        function updateModeSectionsVisibility() {
            // Mode 3 (Assign Tokens) visibility is handled by sentence selection.
            // Its functionality (dropdown enabled/disabled) is based on modeStatus.mode2VuAdded.

            // Sections *within* annotationModesContainer:
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Now remove the heading "Assign Tokens to Verbal Units", the instructions beginning "Click on lexical tokens in the sentence display (below) to assign/unassign them. ", and the status display for that task, so that the menu to select verbal units is directly above the sentence token display.
  
Change the heading "Annotation 4: Define Token Relations" to "Define Token Relations".

### ASSISTANT
Okay, I've made those changes.

1.  **"Assign Tokens to Verbal Units" section (`mode3Section`) cleanup:**
    *   The `<h3>Assign Tokens to Verbal Units</h3>` was already removed in the previous step.
    *   The instructional `<p>` and status `<p>` were also removed in the previous step.
    *   The `mode3Section` now *only* contains the label and dropdown for selecting a verbal unit, making it very compact and appearing directly above the sentence token display.
    *   The CSS ` #mode3Section { padding-bottom: 5px; margin-bottom: 0; border-bottom: none; }` ensures it integrates cleanly.

2.  **Heading Change for "Annotation 4":**
    *   The heading for `mode4Section` has been changed from `<h3>Annotation 4: Define Token Relations</h3>` to `<h3>Define Token Relations</h3>`.

Here is the complete updated HTML:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        #mode3Section { padding-top: 10px; padding-bottom: 5px; margin-bottom: 0; border: none; } /* Further reduced padding, removed border */
        .hidden { display: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Select Verbal Unit to assign tokens to -->
        <div id="mode3Section" class="mode-section hidden"> 
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>Verbal Unit Structure</h3>
            <div id="verbalUnitTextView">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>Syntax Graph Visualization</h3>
                <label for="graphOrientation">Graph Orientation:</label>
                <select id="graphOrientation">
                    <option value="TB">Top to Bottom (TB)</option>
                    <option value="LR">Left to Right (LR)</option>
                </select>
                <div id="mermaidGraphContainer" class="mermaid-container">
                    <!-- Mermaid graph will be rendered here -->
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer'); 
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3 (Only label and select remain)
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens(); // Re-render if VU selection changes, to clear highlights if needed
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                if (token.type === 'lexical') { 
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { 
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once relations are defined and multiple tokens are assigned to a verbal unit.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        function updateModeSectionsVisibility() {
            // mode3Section visibility is tied to sentence selection and mode1Complete
            mode3Section.classList.toggle('hidden', !currentAnnotation.sentenceUrn || !modeStatus.mode1Complete);

            // Sections *within* annotationModesContainer:
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
  
This is excellent. I would like to make 2 sections collapsible so the user can expand or hide their contents: 1) the section labelled "Verbal Unit Structure" with the hierarchically indented display and 2)  the section labelled "Syntax Graph Visualization" with the display of the mermaid graph.
  
I would like to alter the menu labelled "Graph Orientation:" where the user chooses the direction of the mermaid graph. It should have two `option` elements: the first should have the `BT` and have text contents "Top to bottom";the second should have the value `RL` and have text contents "Left to right".

### ASSISTANT
Okay, I've implemented the collapsible sections and updated the graph orientation menu options as requested.

**Key Changes:**

1.  **Collapsible Sections:**
    *   **"Verbal Unit Structure"**:
        *   A toggle button `[–]` / `[+]` is added next to the heading.
        *   The `div#verbalUnitTextView` is now the collapsible content.
        *   Defaults to expanded.
    *   **"Syntax Graph Visualization"**:
        *   A toggle button `[–]` / `[+]` is added next to the heading.
        *   The graph orientation dropdown and the `mermaidGraphContainer` are wrapped in a new `div#mermaidGraphContentWrapper` which is the collapsible content.
        *   Defaults to expanded.
    *   New CSS class `content-hidden-by-toggle` is used to hide collapsed content.
    *   JavaScript handles the toggling and button text update.

2.  **Graph Orientation Menu (`graphOrientationSelect`):**
    *   Options have been changed to:
        *   `value="BT"`, text "Top to bottom"
        *   `value="RL"`, text "Left to right"
    *   The Mermaid rendering will use these values directly, meaning "Top to bottom" will actually render as "Bottom to Top" as per Mermaid's `BT` directive.

Here is the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; display: flex; justify-content: space-between; align-items: center; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .toggle-button { /* Style for [+] / [-] buttons */
            background-color: #eee; color: #333; padding: 2px 8px; font-size: 0.9em;
            border: 1px solid #ccc; margin-left: 10px; margin-top: 0;
        }
        .toggle-button:hover { background-color: #ddd; }

        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        #mode3Section { padding-top: 10px; padding-bottom: 5px; margin-bottom: 0; border: none; } 
        .hidden { display: none; }
        .content-hidden-by-toggle { display: none; } /* Class to hide collapsible content */
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
            margin-top: 5px; /* Space between header and content */
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Select Verbal Unit to assign tokens to -->
        <div id="mode3Section" class="mode-section hidden"> 
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>
                Verbal Unit Structure
                <button class="toggle-button" data-controls="verbalUnitTextView">[–]</button>
            </h3>
            <div id="verbalUnitTextView" class="collapsible-content-area">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>
                    Syntax Graph Visualization
                    <button class="toggle-button" data-controls="mermaidGraphContentWrapper">[–]</button>
                </h3>
                <div id="mermaidGraphContentWrapper" class="collapsible-content-area">
                    <label for="graphOrientation">Graph Orientation:</label>
                    <select id="graphOrientation">
                        <option value="BT">Top to bottom</option>
                        <option value="RL">Left to right</option>
                    </select>
                    <div id="mermaidGraphContainer" class="mermaid-container">
                        <!-- Mermaid graph will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer'); 
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3 (Only label and select remain)
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);

            // Initialize collapsible sections
            document.querySelectorAll('.toggle-button').forEach(button => {
                button.addEventListener('click', function() {
                    const targetId = this.dataset.controls;
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.classList.toggle('content-hidden-by-toggle');
                        this.textContent = targetElement.classList.contains('content-hidden-by-toggle') ? '[+]' : '[–]';
                    }
                });
            });
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                if (token.type === 'lexical') { 
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { 
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once relations are defined and multiple tokens are assigned to a verbal unit.';
                return;
            }

            const orientation = graphOrientationSelect.value; // Will be "BT" or "RL"
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !currentAnnotation.sentenceUrn || !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
In the display of tokens in the section labelled "Verbal Unit Structure", please color the texts according to the verbal unit they belong to, as in the display of sentence tokens in the section imediately before it.

### ASSISTANT
Okay, I've updated the `renderVerbalUnitTextView` function to apply the background color of the assigned verbal unit to each token's `<span>` in that display.

The relevant change is in the `renderVerbalUnitTextView` function:

```javascript
        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    
                    // **** ADDED THIS LINE ****
                    tokenSpan.style.backgroundColor = verbalUnit.color; 
                    // **** END OF ADDED LINE ****

                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
```

The rest of the application remains the same. Here's the complete updated HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; display: flex; justify-content: space-between; align-items: center; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .toggle-button { 
            background-color: #eee; color: #333; padding: 2px 8px; font-size: 0.9em;
            border: 1px solid #ccc; margin-left: 10px; margin-top: 0;
        }
        .toggle-button:hover { background-color: #ddd; }

        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        #mode3Section { padding-top: 10px; padding-bottom: 5px; margin-bottom: 0; border: none; } 
        .hidden { display: none; }
        .content-hidden-by-toggle { display: none; } 
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
            margin-top: 5px; 
        }
        #verbalUnitTextView span { /* To ensure padding for background color */
            padding: 1px 2px;
            border-radius: 2px;
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Select Verbal Unit to assign tokens to -->
        <div id="mode3Section" class="mode-section hidden"> 
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>
                Verbal Unit Structure
                <button class="toggle-button" data-controls="verbalUnitTextView">[–]</button>
            </h3>
            <div id="verbalUnitTextView" class="collapsible-content-area">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>
                    Syntax Graph Visualization
                    <button class="toggle-button" data-controls="mermaidGraphContentWrapper">[–]</button>
                </h3>
                <div id="mermaidGraphContentWrapper" class="collapsible-content-area">
                    <label for="graphOrientation">Graph Orientation:</label>
                    <select id="graphOrientation">
                        <option value="BT">Top to bottom</option>
                        <option value="RL">Left to right</option>
                    </select>
                    <div id="mermaidGraphContainer" class="mermaid-container">
                        <!-- Mermaid graph will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer'); 
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3 (Only label and select remain)
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);

            document.querySelectorAll('.toggle-button').forEach(button => {
                button.addEventListener('click', function() {
                    const targetId = this.dataset.controls;
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.classList.toggle('content-hidden-by-toggle');
                        this.textContent = targetElement.classList.contains('content-hidden-by-toggle') ? '[+]' : '[–]';
                    }
                });
            });
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                if (token.type === 'lexical') { 
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    tokenSpan.style.backgroundColor = verbalUnit.color; // Apply VU color

                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { 
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once relations are defined and multiple tokens are assigned to a verbal unit.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !currentAnnotation.sentenceUrn || !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            a.download = `annotations_${sentenceIdPart.replace(/\./g, '_')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
Fantastic! Now let's let the user choose the name of the output file when downloading annotations. Keep the same base name you're currently using, but with extension `.cex` instead of `.txt`.

### ASSISTANT
Okay, I've updated the `handleDownloadAnnotations` function to prompt the user for the output filename, using the current base name as the default, and ensuring the final file has a `.cex` extension.

Here's how the `handleDownloadAnnotations` function has been modified:

```javascript
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            const defaultBaseName = `annotations_${sentenceIdPart.replace(/\./g, '_')}`;
            
            let userFileName = prompt("Enter filename for download (without extension):", defaultBaseName);

            if (userFileName === null) { // User pressed Cancel
                return; // Abort download
            }
            if (userFileName.trim() === "") { // User entered empty string or just whitespace
                userFileName = defaultBaseName; // Use default
            }
            
            // Ensure .cex extension, remove any existing .txt or .cex the user might have typed
            userFileName = userFileName.replace(/\.cex$/i, '').replace(/\.txt$/i, '');
            const finalFileName = `${userFileName}.cex`;


            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' }); // Mime type for .cex might be application/octet-stream or text/plain
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
```

The rest of the application remains unchanged. Here's the complete file with this update:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek Text Annotator</title>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/cex-lib/cex.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/neelsmith/greeklib@1.1.0/greeklib.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #555; display: flex; justify-content: space-between; align-items: center; }
        label { display: block; margin-top: 10px; }
        input[type="text"], input[type="number"], select {
            width: 90%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;
        }
        button {
            background-color: #007bff; color: white; padding: 10px 15px; border: none;
            border-radius: 4px; cursor: pointer; margin-top: 10px; margin-right: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .toggle-button { 
            background-color: #eee; color: #333; padding: 2px 8px; font-size: 0.9em;
            border: 1px solid #ccc; margin-left: 10px; margin-top: 0;
        }
        .toggle-button:hover { background-color: #ddd; }

        .token-display { margin-top: 15px; padding: 10px; border: 1px solid #eee; line-height: 2.5em; }
        .token { cursor: pointer; padding: 2px 4px; border-radius: 3px; margin-right: 1px;}
        .token.lexical:hover { background-color: #e0e0e0; }
        .token sup { color: silver; font-size: 0.7em; margin-left: 1px; }
        .token.connecting-word { background-color: yellow; }
        .mode-section { margin-top: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 4px; }
        #mode3Section { padding-top: 10px; padding-bottom: 5px; margin-bottom: 0; border: none; } 
        .hidden { display: none; }
        .content-hidden-by-toggle { display: none; } 
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f0f0f0; }
        .delete-btn { background-color: #dc3545; }
        .delete-btn:hover { background-color: #c82333; }
        .mermaid-container { margin-top: 15px; border: 1px solid #ccc; padding: 10px; min-height: 100px; }
        
        #verbalUnitTextView { 
            white-space: pre-wrap; 
            line-height: 1.8em; 
            padding: 10px; 
            border: 1px solid #eee; 
            background-color: #f9f9f9; 
            min-height: 50px;
            margin-top: 5px; 
        }
        #verbalUnitTextView span { 
            padding: 1px 2px;
            border-radius: 2px;
        }
        .vu-line { }
        .vu-line-indent-0 { margin-left: 0; }
        .vu-line-indent-1 { margin-left: 1.5em; }
        .vu-line-indent-2 { margin-left: 3em; }
        .vu-line-indent-3 { margin-left: 4.5em; }
        .vu-line-indent-4 { margin-left: 6em; } 
        .vu-line-indent-5 { margin-left: 7.5em; }

        .node-rel-unit-verb { 
            border: 1px solid black; 
            padding: 0 1px; 
            display: inline-block; 
            line-height: normal; 
            border-radius: 2px;
        }
        .node-rel-subject { text-decoration: underline; }
        .node-rel-dobj-pred { text-decoration: underline overline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Greek Text Annotator</h1>

        <!-- Data Loading Section -->
        <div id="dataLoadingSection">
            <h2 id="loadCorpusHeading">1. Load Corpus and Choose Sentence</h2>
            <label for="cexUrl">CEX Corpus URL:</label>
            <input type="text" id="cexUrl" value="https://raw.githubusercontent.com/neelsmith/eagl-texts/refs/heads/main/texts/herodotus.cex">
            <button id="loadCexBtn">Load CEX Data</button>
            <div id="loadingStatus"></div>

            <label for="sentenceSelector">Select Sentence:</label>
            <select id="sentenceSelector" disabled></select>
        </div>

        <!-- Mode 1: Asyndeton / Connecting Word -->
        <div id="mode1Section" class="mode-section hidden">
            <h3>Asyndeton / Connecting Word</h3>
            <label>
                <input type="checkbox" id="asyndetonCheckbox"> This sentence illustrates asyndeton.
            </label>
            <p id="mode1Prompt">If not asyndeton, click on the connecting lexical token in the sentence above.</p>
            <p>Status: <span id="mode1Status">Pending</span></p>
        </div>

        <!-- Sentence Display Area -->
        <h2 id="annotateSentenceHeading">2. Annotate Sentence</h2>
        
        <!-- Mode 3: Select Verbal Unit to assign tokens to -->
        <div id="mode3Section" class="mode-section hidden"> 
            <label for="vuSelectorForAssignment">Select Verbal Unit to assign tokens to:</label>
            <select id="vuSelectorForAssignment" disabled></select>
        </div>

        <div id="sentenceTokenDisplay" class="token-display">Select a sentence to see tokens.</div>

        <!-- Verbal Unit Text Display -->
        <div id="verbalUnitTextDisplaySection" class="mode-section hidden"> 
            <h3>
                Verbal Unit Structure
                <button class="toggle-button" data-controls="verbalUnitTextView">[–]</button>
            </h3>
            <div id="verbalUnitTextView" class="collapsible-content-area">
                <!-- Content will be generated here -->
            </div>
        </div>
        
        <!-- Annotation Modes Container (for modes 2, graph, 4) -->
        <div id="annotationModesContainer" class="hidden">
            <!-- Mode 2: Verbal Units -->
            <div id="mode2Section" class="mode-section hidden">
                <h3>Define Verbal Units</h3>
                <table id="verbalUnitsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Syntactic Type</th>
                            <th>Semantic Type</th>
                            <th>Depth</th>
                            <th>Color</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <h4>Add New Verbal Unit:</h4>
                <label for="vuSyntacticType">Syntactic Type:</label>
                <select id="vuSyntacticType">
                    <option value="independent clause">independent clause</option>
                    <option value="subordinate clause">subordinate clause</option>
                    <option value="circumstantial participle">circumstantial participle</option>
                    <option value="attributive participle">attributive participle</option>
                    <option value="indirect statement with infinitive">indirect statement with infinitive</option>
                    <option value="indirect statement with participle">indirect statement with participle</option>
                </select>
                <label for="vuSemanticType">Semantic Type:</label>
                <select id="vuSemanticType">
                    <option value="transitive">transitive</option>
                    <option value="intransitive">intransitive</option>
                    <option value="linking">linking</option>
                </select>
                <label for="vuDepth">Depth (integer):</label>
                <input type="number" id="vuDepth" value="0">
                <button id="addVuBtn">Add and Confirm Verbal Unit</button>
                <p>Status: <span id="mode2Status">Pending first verbal unit.</span></p>
            </div>

            <!-- Mermaid Graph Visualization -->
            <div id="mermaidGraphSection" class="mode-section hidden">
                <h3>
                    Syntax Graph Visualization
                    <button class="toggle-button" data-controls="mermaidGraphContentWrapper">[–]</button>
                </h3>
                <div id="mermaidGraphContentWrapper" class="collapsible-content-area">
                    <label for="graphOrientation">Graph Orientation:</label>
                    <select id="graphOrientation">
                        <option value="BT">Top to bottom</option>
                        <option value="RL">Left to right</option>
                    </select>
                    <div id="mermaidGraphContainer" class="mermaid-container">
                        <!-- Mermaid graph will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Mode 4: Token Relations -->
            <div id="mode4Section" class="mode-section hidden">
                <h3>Define Token Relations</h3>
                <table id="relationsTable">
                    <thead>
                        <tr>
                            <th>Reference</th>
                            <th>Token</th>
                            <th>Node 1 (ID)</th>
                            <th>Node 1 Relation</th>
                            <th>Node 2 (ID)</th>
                            <th>Node 2 Relation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <button id="addImpliedTokenBtn">Add Implied Token Row</button>
            </div>
        </div>

        <!-- Data Download Section -->
        <div id="dataDownloadSection" class="mode-section hidden">
            <h2>3. Download Annotations</h2>
            <button id="downloadAnnotationsBtn" disabled>Download Annotations for Current Sentence</button>
        </div>
    </div>

    <script>
        // --- Global State and Constants ---
        let ALL_CORPUS_TOKENS = [];
        let SENTENCE_REFERENCES = []; 
        
        let currentAnnotation = {
            sentenceUrn: null,
            sentenceCtsUrn: null, 
            sentenceSequenceInMenu: -1,
            isAsyndeton: false,
            connectorTokenUrn: null,
            verbalUnits: [], 
            tokenToVuMap: {}, 
            relations: [], 
            selectedSentenceTokens: [] 
        };

        let modeStatus = {
            mode1Complete: false,
            mode2VuAdded: false, 
            mode3MinTokensForVu: false 
        };

        const PASTEL_COLORS = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4', '#FFDAC1', '#B5EAD7', '#C7CEEA'];
        let nextPastelColorIndex = 0;
        let impliedTokenCounter = -1;

        const NODE_RELATION_TYPES = [
            "conjunction", "subordinate conjunction", "relative pronoun", "unit verb", 
            "predicate", "subject", "direct object", "agent", "object of preposition", 
            "direct address", "complementary infinitive", "supplementary participle", 
            "modal particle", "adverbial", "attributive", "article", "pronoun", 
            "dative", "genitive"
        ];

        // --- DOM Elements ---
        const cexUrlInput = document.getElementById('cexUrl');
        const loadCexBtn = document.getElementById('loadCexBtn');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const sentenceSelector = document.getElementById('sentenceSelector');
        const sentenceTokenDisplay = document.getElementById('sentenceTokenDisplay');
        const verbalUnitTextDisplaySection = document.getElementById('verbalUnitTextDisplaySection');
        const verbalUnitTextView = document.getElementById('verbalUnitTextView');
        
        const mode1Section = document.getElementById('mode1Section'); 
        const mode3Section = document.getElementById('mode3Section'); 
        const annotationModesContainer = document.getElementById('annotationModesContainer'); 
        // Mode 1
        const asyndetonCheckbox = document.getElementById('asyndetonCheckbox');
        const mode1Prompt = document.getElementById('mode1Prompt');
        const mode1Status = document.getElementById('mode1Status');
        // Mode 3 (Only label and select remain)
        const vuSelectorForAssignment = document.getElementById('vuSelectorForAssignment');
        // Mode 2
        const mode2Section = document.getElementById('mode2Section');
        const verbalUnitsTableBody = document.getElementById('verbalUnitsTable').getElementsByTagName('tbody')[0];
        const vuSyntacticTypeSelect = document.getElementById('vuSyntacticType');
        const vuSemanticTypeSelect = document.getElementById('vuSemanticType');
        const vuDepthInput = document.getElementById('vuDepth');
        const addVuBtn = document.getElementById('addVuBtn');
        const mode2Status = document.getElementById('mode2Status');
        // Mermaid Graph
        const mermaidGraphSection = document.getElementById('mermaidGraphSection'); 
        const graphOrientationSelect = document.getElementById('graphOrientation');
        const mermaidGraphContainer = document.getElementById('mermaidGraphContainer');
        // Mode 4
        const mode4Section = document.getElementById('mode4Section');
        const relationsTableBody = document.getElementById('relationsTable').getElementsByTagName('tbody')[0];
        const addImpliedTokenBtn = document.getElementById('addImpliedTokenBtn');
        // Download
        const dataDownloadSection = document.getElementById('dataDownloadSection');
        const downloadAnnotationsBtn = document.getElementById('downloadAnnotationsBtn');

        // --- Initialization ---
        window.onload = () => {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
            loadCexBtn.addEventListener('click', handleLoadCex);
            sentenceSelector.addEventListener('change', handleSentenceSelect);
            asyndetonCheckbox.addEventListener('change', handleAsyndetonCheck);
            addVuBtn.addEventListener('click', handleAddVerbalUnit);
            vuSelectorForAssignment.addEventListener('change', () => { 
                renderSentenceTokens();
            }); 
            addImpliedTokenBtn.addEventListener('click', handleAddImpliedToken);
            graphOrientationSelect.addEventListener('change', renderMermaidGraph);
            downloadAnnotationsBtn.addEventListener('click', handleDownloadAnnotations);

            document.querySelectorAll('.toggle-button').forEach(button => {
                button.addEventListener('click', function() {
                    const targetId = this.dataset.controls;
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.classList.toggle('content-hidden-by-toggle');
                        this.textContent = targetElement.classList.contains('content-hidden-by-toggle') ? '[+]' : '[–]';
                    }
                });
            });
        };

        // --- CEX Loading and Sentence Selection ---
        function handleLoadCex() {
            const url = cexUrlInput.value;
            loadingStatusDiv.textContent = 'Loading CEX data...';
            sentenceSelector.disabled = true;
            sentenceSelector.innerHTML = '<option>Loading...</option>';

            const parser = new CEXParser();
            parser.loadFromUrl(url)
                .then(p => {
                    loadingStatusDiv.textContent = 'CEX data loaded. Processing...';
                    const ctsDataString = p.getDelimitedData("ctsdata");
                    if (!ctsDataString) {
                        loadingStatusDiv.textContent = 'Error: No "ctsdata" block found in CEX file.';
                        return;
                    }
                    const ctsDataLines = ctsDataString.split('\n').filter(line => line.trim() !== '');
                    
                    ALL_CORPUS_TOKENS = greeklib.tokenize(ctsDataLines);
                    SENTENCE_REFERENCES = greeklib.sentences(ctsDataLines).map((urn, index) => ({
                        urn: urn,
                        text: `${index + 1}. ${urn.split(':').pop()}` 
                    }));

                    populateSentenceSelector();
                    loadingStatusDiv.textContent = 'Corpus loaded. Select a sentence.';
                    sentenceSelector.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load from URL:', error);
                    loadingStatusDiv.textContent = `Failed to load CEX data: ${error.message}`;
                });
        }

        function populateSentenceSelector() {
            sentenceSelector.innerHTML = '<option value="">-- Select a Sentence --</option>';
            SENTENCE_REFERENCES.forEach((ref, index) => {
                const option = document.createElement('option');
                option.value = ref.urn;
                option.textContent = ref.text;
                option.dataset.index = index;
                sentenceSelector.appendChild(option);
            });
        }

        function handleSentenceSelect() {
            const selectedUrn = sentenceSelector.value;
            if (!selectedUrn) {
                resetAnnotationEnvironment();
                return;
            }
            const selectedOption = sentenceSelector.options[sentenceSelector.selectedIndex];
            
            resetAnnotationEnvironment(); 

            currentAnnotation.sentenceCtsUrn = selectedUrn;
            currentAnnotation.sentenceSequenceInMenu = parseInt(selectedOption.dataset.index);
            currentAnnotation.selectedSentenceTokens = greeklib.tokens(selectedUrn, ALL_CORPUS_TOKENS);
            
            if (currentAnnotation.selectedSentenceTokens.length > 0) {
                 currentAnnotation.sentenceUrn = currentAnnotation.selectedSentenceTokens[0].urn.substring(0, currentAnnotation.selectedSentenceTokens[0].urn.lastIndexOf(':') +1) + selectedUrn.split(':').pop();
            } else {
                 currentAnnotation.sentenceUrn = selectedUrn; 
            }

            mode1Section.classList.remove('hidden'); 
            mode3Section.classList.remove('hidden'); 
            verbalUnitTextDisplaySection.classList.remove('hidden');
            annotationModesContainer.classList.remove('hidden'); 
            dataDownloadSection.classList.remove('hidden');
            downloadAnnotationsBtn.disabled = true; 

            initializeMode1();
            initializeMode4TableStructure(); 
            renderSentenceTokens();
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }
        
        function resetAnnotationEnvironment() {
            currentAnnotation = {
                sentenceUrn: null,
                sentenceCtsUrn: null,
                sentenceSequenceInMenu: -1,
                isAsyndeton: false,
                connectorTokenUrn: null,
                verbalUnits: [],
                tokenToVuMap: {},
                relations: [],
                selectedSentenceTokens: []
            };
            modeStatus = { mode1Complete: false, mode2VuAdded: false, mode3MinTokensForVu: false };
            
            sentenceTokenDisplay.innerHTML = 'Select a sentence to see tokens.';
            verbalUnitTextView.innerHTML = ''; 
            asyndetonCheckbox.checked = false;
            mode1Status.textContent = 'Pending';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';

            verbalUnitsTableBody.innerHTML = '';
            vuSelectorForAssignment.innerHTML = '';
            vuSelectorForAssignment.disabled = true;
            relationsTableBody.innerHTML = '';
            mermaidGraphContainer.innerHTML = '';
            
            nextPastelColorIndex = 0;
            impliedTokenCounter = -1;

            mode1Section.classList.add('hidden'); 
            mode3Section.classList.add('hidden'); 
            verbalUnitTextDisplaySection.classList.add('hidden'); 
            annotationModesContainer.classList.add('hidden'); 
            dataDownloadSection.classList.add('hidden');
            updateModeSectionsVisibility(); 
        }

        function getTokenStylingClasses(tokenSequence) {
            const classes = [];
            if (tokenSequence === null || tokenSequence === undefined) return classes;

            const relation = currentAnnotation.relations.find(r => r.reference === tokenSequence);
            if (relation && relation.node1Rel) {
                switch (relation.node1Rel) {
                    case 'unit verb':
                        classes.push('node-rel-unit-verb');
                        break;
                    case 'subject':
                        classes.push('node-rel-subject');
                        break;
                    case 'direct object':
                    case 'predicate':
                        classes.push('node-rel-dobj-pred');
                        break;
                }
            }
            return classes;
        }

        function renderSentenceTokens() {
            sentenceTokenDisplay.innerHTML = '';
            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                sentenceTokenDisplay.textContent = 'No tokens for this sentence.';
                return;
            }

            currentAnnotation.selectedSentenceTokens.forEach((token, index) => {
                const tokenSpan = document.createElement('span');
                tokenSpan.classList.add('token');
                tokenSpan.dataset.urn = token.urn;
                tokenSpan.dataset.sequence = token.sequence; 
                tokenSpan.dataset.type = token.type;

                if (token.type === 'lexical') { 
                    const stylingClasses = getTokenStylingClasses(token.sequence);
                    stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                }

                let tokenTextContent = token.text;
                
                if (token.type === 'lexical') {
                    tokenSpan.classList.add('lexical');
                    tokenSpan.title = `URN: ${token.urn}\nSequence: ${token.sequence}`;
                    
                    const sup = document.createElement('sup');
                    sup.textContent = token.sequence;
                    
                    tokenSpan.appendChild(document.createTextNode(tokenTextContent));
                    tokenSpan.appendChild(sup);
                    
                    tokenSpan.addEventListener('click', () => handleTokenClick(token));

                    if (modeStatus.mode1Complete && !currentAnnotation.isAsyndeton && token.urn === currentAnnotation.connectorTokenUrn) {
                        tokenSpan.classList.add('connecting-word');
                    }
                    const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                    if (assignedVuId) {
                        const vu = currentAnnotation.verbalUnits.find(v => v.id === assignedVuId);
                        if (vu) {
                            tokenSpan.style.backgroundColor = vu.color;
                            tokenSpan.title += `\nAssigned to VU: ${vu.id.slice(-4)} (${vu.syntacticType})`;
                        }
                    }

                } else { 
                    tokenSpan.textContent = tokenTextContent;
                }

                sentenceTokenDisplay.appendChild(tokenSpan);

                let nextTokenIsPunctuation = false;
                if (index + 1 < currentAnnotation.selectedSentenceTokens.length) {
                    nextTokenIsPunctuation = currentAnnotation.selectedSentenceTokens[index + 1].type === 'punctuation';
                }

                if (token.type === 'punctuation') {
                    sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                } else if (token.type === 'lexical') {
                    if (!nextTokenIsPunctuation) {
                        sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                    }
                } else { 
                     sentenceTokenDisplay.appendChild(document.createTextNode(' '));
                }
            });
        }

        function renderVerbalUnitTextView() {
            verbalUnitTextView.innerHTML = ''; 

            if (!currentAnnotation.selectedSentenceTokens || currentAnnotation.selectedSentenceTokens.length === 0) {
                verbalUnitTextView.textContent = 'No tokens to display.';
                return;
            }

            let currentLineDiv = null;
            let lastVuIdForLine = null;
            let anythingRendered = false;

            currentAnnotation.selectedSentenceTokens.forEach(token => {
                const assignedVuId = currentAnnotation.tokenToVuMap[token.urn];
                
                if (assignedVuId) { 
                    anythingRendered = true;
                    const verbalUnit = currentAnnotation.verbalUnits.find(vu => vu.id === assignedVuId);
                    if (!verbalUnit) return; 

                    if (assignedVuId !== lastVuIdForLine) { 
                        currentLineDiv = document.createElement('div');
                        currentLineDiv.classList.add('vu-line');
                        const indentLevel = Math.max(0, verbalUnit.depth - 1); 
                        currentLineDiv.classList.add(`vu-line-indent-${indentLevel}`);
                        verbalUnitTextView.appendChild(currentLineDiv);
                        lastVuIdForLine = assignedVuId;
                    }
                    
                    const tokenSpan = document.createElement('span');
                    tokenSpan.textContent = token.text;
                    tokenSpan.style.backgroundColor = verbalUnit.color; 

                    if (token.type === 'lexical') {
                        const stylingClasses = getTokenStylingClasses(token.sequence);
                        stylingClasses.forEach(cls => tokenSpan.classList.add(cls));
                    }
                    
                    if (currentLineDiv.childNodes.length > 0) { 
                        currentLineDiv.appendChild(document.createTextNode(' '));
                    }
                    currentLineDiv.appendChild(tokenSpan);
                }
            });

            if (!anythingRendered) {
                verbalUnitTextView.textContent = 'No tokens assigned to verbal units yet, or no verbal units defined.';
            }
        }
        
        function handleTokenClick(token) {
            if (!modeStatus.mode1Complete && !asyndetonCheckbox.checked && token.type === 'lexical') {
                currentAnnotation.connectorTokenUrn = token.urn;
                mode1Prompt.textContent = `Selected connector: ${token.text} (URN: ${token.urn})`;
                completeMode1();
                renderSentenceTokens(); 
            }
            else if (modeStatus.mode1Complete && token.type === 'lexical') { 
                if (!modeStatus.mode2VuAdded) { 
                    alert("Please define Verbal Units (further below) to enable selection, before assigning tokens.");
                    return;
                }
                const selectedVuId = vuSelectorForAssignment.value;
                if (!selectedVuId) {
                    alert('Please select a verbal unit from the dropdown first.');
                    return;
                }

                const currentAssignment = currentAnnotation.tokenToVuMap[token.urn];
                if (currentAssignment === selectedVuId) { 
                    delete currentAnnotation.tokenToVuMap[token.urn];
                } else { 
                    currentAnnotation.tokenToVuMap[token.urn] = selectedVuId;
                }
                checkMinTokensForVU(); 
                renderSentenceTokens(); 
                renderVerbalUnitTextView(); 
                updateModeSectionsVisibility(); 
                renderRelationsTable(); 
            }
        }

        // --- Mode 1: Asyndeton / Connecting Word ---
        function initializeMode1() {
            modeStatus.mode1Complete = false;
            asyndetonCheckbox.checked = false;
            currentAnnotation.isAsyndeton = false;
            currentAnnotation.connectorTokenUrn = null;
            mode1Status.textContent = 'Pending. Make a selection.';
            mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            downloadAnnotationsBtn.disabled = true;
        }

        function handleAsyndetonCheck() {
            if (asyndetonCheckbox.checked) {
                currentAnnotation.isAsyndeton = true;
                currentAnnotation.connectorTokenUrn = null;
                mode1Prompt.textContent = 'Asyndeton selected.';
                completeMode1();
                renderSentenceTokens(); 
            } else {
                currentAnnotation.isAsyndeton = false;
                if (modeStatus.mode1Complete) {
                     modeStatus.mode1Complete = false; 
                     mode1Status.textContent = 'Asyndeton unchecked. Select a connector token.';
                     downloadAnnotationsBtn.disabled = true;
                     updateModeSectionsVisibility(); 
                }
                 mode1Prompt.textContent = 'If not asyndeton, click on the connecting lexical token in the sentence above.';
            }
        }

        function completeMode1() {
            if (currentAnnotation.isAsyndeton || currentAnnotation.connectorTokenUrn) {
                modeStatus.mode1Complete = true;
                mode1Status.textContent = `Complete. ${currentAnnotation.isAsyndeton ? 'Asyndeton.' : 'Connector: ' + (currentAnnotation.selectedSentenceTokens.find(t=>t.urn === currentAnnotation.connectorTokenUrn)?.text || 'N/A')}`;
                downloadAnnotationsBtn.disabled = false;
                updateModeSectionsVisibility();
            }
        }
        
        // --- Mode 2: Verbal Units ---
        function handleAddVerbalUnit() {
            const syntacticType = vuSyntacticTypeSelect.value;
            const semanticType = vuSemanticTypeSelect.value;
            const depth = parseInt(vuDepthInput.value);

            if (isNaN(depth) || depth < 0) { 
                alert('Depth must be a non-negative integer.');
                return;
            }

            const newVu = {
                id: `vu_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
                syntacticType,
                semanticType,
                depth,
                color: PASTEL_COLORS[nextPastelColorIndex % PASTEL_COLORS.length],
                sentenceUrn: currentAnnotation.sentenceCtsUrn 
            };
            nextPastelColorIndex++;
            currentAnnotation.verbalUnits.push(newVu);
            
            modeStatus.mode2VuAdded = true; 
            mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function renderVerbalUnitsTable() {
            verbalUnitsTableBody.innerHTML = '';
            currentAnnotation.verbalUnits.forEach(vu => {
                const row = verbalUnitsTableBody.insertRow();
                row.insertCell().textContent = vu.id.slice(-6); 
                row.insertCell().textContent = vu.syntacticType;
                row.insertCell().textContent = vu.semanticType;
                row.insertCell().textContent = vu.depth;
                const colorCell = row.insertCell();
                colorCell.style.backgroundColor = vu.color;
                
                const actionsCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = () => handleDeleteVerbalUnit(vu.id);
                actionsCell.appendChild(deleteBtn);
            });
        }

        function handleDeleteVerbalUnit(vuId) {
            Object.keys(currentAnnotation.tokenToVuMap).forEach(tokenUrn => {
                if (currentAnnotation.tokenToVuMap[tokenUrn] === vuId) {
                    delete currentAnnotation.tokenToVuMap[tokenUrn];
                }
            });
            currentAnnotation.verbalUnits = currentAnnotation.verbalUnits.filter(vu => vu.id !== vuId);

            if (currentAnnotation.verbalUnits.length === 0) {
                modeStatus.mode2VuAdded = false;
                mode2Status.textContent = 'Pending first verbal unit.';
            } else {
                 mode2Status.textContent = `Verbal units defined: ${currentAnnotation.verbalUnits.length}.`;
            }
            
            checkMinTokensForVU(); 
            renderVerbalUnitsTable();
            updateVuSelectorForAssignment(); 
            renderSentenceTokens(); 
            renderVerbalUnitTextView(); 
            updateModeSectionsVisibility(); 
        }

        function updateVuSelectorForAssignment() { 
            vuSelectorForAssignment.innerHTML = '<option value="">-- Select VU --</option>';
            if (currentAnnotation.verbalUnits.length > 0) {
                currentAnnotation.verbalUnits.forEach(vu => {
                    const option = document.createElement('option');
                    option.value = vu.id;
                    option.textContent = `${vu.syntacticType} (ID: ...${vu.id.slice(-4)})`;
                    option.style.backgroundColor = vu.color;
                    vuSelectorForAssignment.appendChild(option);
                });
                vuSelectorForAssignment.disabled = false; 
            } else {
                vuSelectorForAssignment.disabled = true; 
            }
        }

        function checkMinTokensForVU() { 
            const tokenCountsByVu = {};
            currentAnnotation.verbalUnits.forEach(vu => tokenCountsByVu[vu.id] = 0);
            
            Object.values(currentAnnotation.tokenToVuMap).forEach(vuId => {
                if (tokenCountsByVu.hasOwnProperty(vuId)) {
                    tokenCountsByVu[vuId]++;
                }
            });
            
            modeStatus.mode3MinTokensForVu = Object.values(tokenCountsByVu).some(count => count > 1);
            updateModeSectionsVisibility(); 
        }

        // --- Mode 4: Token Relations ---
        function initializeMode4TableStructure() {
            currentAnnotation.relations = [];
            currentAnnotation.selectedSentenceTokens.forEach(token => {
                if (token.type === 'lexical') { 
                    currentAnnotation.relations.push({
                        reference: token.sequence, 
                        tokenText: token.text,
                        originalTokenUrn: token.urn, 
                        node1: null, node1Rel: null,
                        node2: null, node2Rel: null
                    });
                }
            });
            impliedTokenCounter = -1; 
            renderRelationsTable(); 
        }
        
        function handleAddImpliedToken() {
            currentAnnotation.relations.push({
                reference: impliedTokenCounter--,
                tokenText: 'implied',
                originalTokenUrn: 'implied',
                node1: null, node1Rel: null,
                node2: null, node2Rel: null
            });
            renderRelationsTable(); 
        }

        function renderRelationsTable() {
            relationsTableBody.innerHTML = '';
            const validReferences = currentAnnotation.relations.map(r => r.reference);

            currentAnnotation.relations.forEach((rel, rowIndex) => {
                const row = relationsTableBody.insertRow();
                row.insertCell().textContent = rel.reference;
                row.insertCell().textContent = rel.tokenText;

                const node1Cell = row.insertCell();
                const node1Input = document.createElement('input');
                node1Input.type = 'number';
                node1Input.value = rel.node1 === null ? '' : rel.node1;
                node1Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                    if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node1 === null ? '' : rel.node1; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node1 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node1Cell.appendChild(node1Input);

                const node1RelCell = row.insertCell();
                const node1RelSelect = createRelationSelect(rel.node1Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node1Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node1RelCell.appendChild(node1RelSelect);
                
                const node2Cell = row.insertCell();
                const node2Input = document.createElement('input');
                node2Input.type = 'number';
                node2Input.value = rel.node2 === null ? '' : rel.node2;
                node2Input.onchange = (e) => {
                    const val = e.target.value === '' ? null : parseInt(e.target.value);
                     if (val !== null && !validReferences.includes(val) && val !== rel.reference) {
                        alert(`Invalid reference ID: ${val}. Must be one of: ${validReferences.join(', ')} or the current token's reference.`);
                        e.target.value = rel.node2 === null ? '' : rel.node2; 
                        return;
                    }
                    currentAnnotation.relations[rowIndex].node2 = val;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                };
                node2Cell.appendChild(node2Input);

                const node2RelCell = row.insertCell();
                const node2RelSelect = createRelationSelect(rel.node2Rel, (newVal) => {
                    currentAnnotation.relations[rowIndex].node2Rel = newVal;
                    renderMermaidGraph();
                    renderSentenceTokens(); 
                    renderVerbalUnitTextView();
                });
                node2RelCell.appendChild(node2RelSelect);

                const actionsCell = row.insertCell();
                if (rel.originalTokenUrn === 'implied') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.onclick = () => {
                        const refToDelete = currentAnnotation.relations[rowIndex].reference;
                        currentAnnotation.relations = currentAnnotation.relations.filter((r, i) => i !== rowIndex);
                        currentAnnotation.relations.forEach(r => {
                            if (r.node1 === refToDelete) { r.node1 = null; r.node1Rel = null; }
                            if (r.node2 === refToDelete) { r.node2 = null; r.node2Rel = null; }
                        });
                        renderRelationsTable(); 
                    };
                    actionsCell.appendChild(deleteBtn);
                }
            });
            renderSentenceTokens(); 
            renderVerbalUnitTextView();
            renderMermaidGraph(); 
        }

        function createRelationSelect(currentValue, onChangeCallback) {
            const select = document.createElement('select');
            const emptyOpt = document.createElement('option');
            emptyOpt.value = "";
            emptyOpt.textContent = "-- Select --";
            select.appendChild(emptyOpt);
            NODE_RELATION_TYPES.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === currentValue) option.selected = true;
                select.appendChild(option);
            });
            select.onchange = (e) => onChangeCallback(e.target.value === "" ? null : e.target.value);
            return select;
        }

        async function renderMermaidGraph() {
            if (!modeStatus.mode3MinTokensForVu) { 
                mermaidGraphContainer.innerHTML = 'Graph will appear here once relations are defined and multiple tokens are assigned to a verbal unit.';
                return;
            }

            const orientation = graphOrientationSelect.value;
            let mermaidDefinition = `graph ${orientation}\n`;
            const nodesInGraph = new Set();

            currentAnnotation.relations.forEach(rel => {
                const sourceId = rel.reference;
                const sourceLabel = rel.tokenText.replace(/"/g, '#quot;'); 

                if (rel.node1 !== null && rel.node1Rel) {
                    const target1Id = rel.node1;
                    const target1 = currentAnnotation.relations.find(r => r.reference === target1Id);
                    if (target1) {
                        const target1Label = target1.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node1Rel}" --> ${target1Id}["${target1Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target1Id);
                    }
                }
                if (rel.node2 !== null && rel.node2Rel) {
                    const target2Id = rel.node2;
                    const target2 = currentAnnotation.relations.find(r => r.reference === target2Id);
                     if (target2) {
                        const target2Label = target2.tokenText.replace(/"/g, '#quot;');
                        mermaidDefinition += `    ${sourceId}["${sourceLabel}"] -- "${rel.node2Rel}" --> ${target2Id}["${target2Label}"]\n`;
                        nodesInGraph.add(sourceId);
                        nodesInGraph.add(target2Id);
                    }
                }
            });
            
            if (nodesInGraph.size === 0) {
                 mermaidGraphContainer.innerHTML = 'No relations defined yet to display in graph.';
                 return;
            }

            try {
                mermaidGraphContainer.innerHTML = ''; 
                const {svg} = await mermaid.render('graphDiv-' + Date.now(), mermaidDefinition);
                mermaidGraphContainer.innerHTML = svg;
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                mermaidGraphContainer.textContent = "Error rendering graph. Check console.";
            }
        }
        
        function updateModeSectionsVisibility() {
            mode3Section.classList.toggle('hidden', !currentAnnotation.sentenceUrn || !modeStatus.mode1Complete);
            mode2Section.classList.toggle('hidden', !modeStatus.mode1Complete);
            
            const showMode4AndGraph = modeStatus.mode3MinTokensForVu;
            mermaidGraphSection.classList.toggle('hidden', !showMode4AndGraph); 
            mode4Section.classList.toggle('hidden', !showMode4AndGraph);
            
            if (showMode4AndGraph) renderMermaidGraph(); 
        }

        // --- Data Download ---
        function handleDownloadAnnotations() {
            if (!modeStatus.mode1Complete) {
                alert("Please complete Annotation 1 (Asyndeton/Connector) before downloading.");
                return;
            }

            let output = "";

            output += "#!sentences\n";
            output += "sentence|sequence|connector\n";
            const connector = currentAnnotation.isAsyndeton ? "" : currentAnnotation.connectorTokenUrn || "";
            output += `${currentAnnotation.sentenceCtsUrn}|${currentAnnotation.sentenceSequenceInMenu}|${connector}\n\n`;

            output += "#!verbal_units\n";
            output += "vuid|syntactic_type|semantic_type|depth|sentence\n";
            currentAnnotation.verbalUnits.forEach(vu => {
                output += `${vu.id}|${vu.syntacticType}|${vu.semanticType}|${vu.depth}|${currentAnnotation.sentenceCtsUrn}\n`;
            });
            output += "\n";

            output += "#!tokens\n";
            output += "urn|reference|tokentype|text|verbalunit|node1|node1relation|node2|node2relation\n";
            
            currentAnnotation.relations.forEach(rel => {
                let tokenUrn = rel.originalTokenUrn; 
                let tokenType = "implied"; 
                let tokenText = rel.tokenText;
                let verbalUnit = "";

                if (tokenUrn !== 'implied') {
                    const originalToken = currentAnnotation.selectedSentenceTokens.find(t => t.urn === tokenUrn);
                    if (originalToken) {
                        tokenType = originalToken.type;
                    }
                    verbalUnit = currentAnnotation.tokenToVuMap[tokenUrn] || "";
                } else { 
                    for (const otherRel of currentAnnotation.relations) {
                        if (otherRel.originalTokenUrn !== 'implied') {
                            if (otherRel.node1 === rel.reference || otherRel.node2 === rel.reference) {
                                verbalUnit = currentAnnotation.tokenToVuMap[otherRel.originalTokenUrn] || "";
                                if (verbalUnit) break;
                            }
                        }
                    }
                    if (!verbalUnit && rel.node1 !== null) {
                        const linkedNode1 = currentAnnotation.relations.find(r => r.reference === rel.node1 && r.originalTokenUrn !== 'implied');
                        if (linkedNode1) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode1.originalTokenUrn] || "";
                    }
                    if (!verbalUnit && rel.node2 !== null) {
                        const linkedNode2 = currentAnnotation.relations.find(r => r.reference === rel.node2 && r.originalTokenUrn !== 'implied');
                        if (linkedNode2) verbalUnit = currentAnnotation.tokenToVuMap[linkedNode2.originalTokenUrn] || "";
                    }
                }
                
                output += `${tokenUrn}|${rel.reference}|${tokenType}|${tokenText}|${verbalUnit}|${rel.node1 === null ? '' : rel.node1}|${rel.node1Rel || ''}|${rel.node2 === null ? '' : rel.node2}|${rel.node2Rel || ''}\n`;
            });

            const sentenceIdPart = currentAnnotation.sentenceCtsUrn.split(':').pop() || 'sentence';
            const defaultBaseName = `annotations_${sentenceIdPart.replace(/\./g, '_')}`;
            
            let userFileName = prompt("Enter filename for download (without extension):", defaultBaseName);

            if (userFileName === null) { 
                return; 
            }
            if (userFileName.trim() === "") { 
                userFileName = defaultBaseName; 
            }
            
            userFileName = userFileName.replace(/\.cex$/i, '').replace(/\.txt$/i, '');
            const finalFileName = `${userFileName}.cex`;


            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' }); 
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = finalFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>
```

### USER
This is great. Could you write a very brief user's guide to using the app?

### ASSISTANT
Okay, here's a brief user's guide for the Greek Text Annotator app:

---

**Greek Text Annotator - User's Guide**

This web app helps you annotate tokens in a Greek text, focusing on asyndeton, verbal units, and syntactic relations.

**1. Load Corpus and Choose Sentence:**
*   **Load Data:**
    *   The app starts with a default URL for a Herodotus text. You can replace this with a URL to any CEX-formatted citable corpus.
    *   Click the "Load CEX Data" button.
    *   Wait for the "Corpus loaded. Select a sentence." status message.
*   **Select Sentence:**
    *   Choose a sentence from the "Select Sentence:" dropdown menu. This will populate the "Annotate Sentence" display.

**2. Annotate Sentence:**
This is the main area where you'll interact with the text.

*   **Asyndeton / Connecting Word (First Annotation Step):**
    *   This section appears after you select a sentence. **You must complete this step before other annotation features become fully active.**
    *   If the sentence illustrates asyndeton, check the "This sentence illustrates asyndeton" box.
    *   Otherwise, click directly on the single lexical token in the "Annotate Sentence" display below that acts as the connecting word. The token will be highlighted yellow.
*   **Select Verbal Unit to assign tokens to:**
    *   This dropdown menu appears directly above the sentence tokens once "Asyndeton / Connecting Word" is completed.
    *   **To use this, you must first define at least one verbal unit in the "Define Verbal Units" section (see below).**
    *   Once verbal units are defined and one is selected here, click on lexical tokens in the "Annotate Sentence" display (token display with superscript numbers) to assign them to the selected verbal unit.
    *   Clicking a token again will unassign it from the *currently selected* verbal unit.
    *   Assigned tokens will be highlighted with their verbal unit's color.
*   **"Annotate Sentence" Display:**
    *   This area shows the tokens of the selected sentence. Lexical tokens are clickable (for Annotation 1 and for assigning to verbal units) and show their sequence number as a superscript.
    *   Tokens in this display will also receive text decorations (underline, overline, border) based on the relations you define in the "Define Token Relations" table (see "Define Token Relations" below).

**3. Verbal Unit Structure:**
*   This section (collapsible via the `[–]` / `[+]` button) displays the text of tokens that you have assigned to verbal units.
*   Tokens belonging to the same verbal unit appear on the same line.
*   A new line starts for tokens belonging to a different verbal unit.
*   Lines are indented based on the "Depth" you assigned to the verbal unit (Deeper VUs are indented further).
*   Tokens are colored according to their assigned verbal unit, and also receive text decorations based on "Define Token Relations."

**4. Define Verbal Units:**
*   This section (found further down, below the visualizations) is where you define the verbal units present in the sentence. It becomes active after completing "Asyndeton / Connecting Word."
*   For each verbal unit:
    *   Choose a "Syntactic Type" from the dropdown.
    *   Choose a "Semantic Type" from the dropdown.
    *   Enter an integer for "Depth" (e.g., 0 or 1 for main clauses, 2 for the next level of subordination, etc.).
    *   Click "Add and Confirm Verbal Unit".
*   Each verbal unit will be added to a table and assigned a unique pastel color. You can delete units from this table.
*   **Defining verbal units here makes them available in the "Select Verbal Unit to assign tokens to:" dropdown above the sentence display.**

**5. Syntax Graph Visualization & Define Token Relations:**
These sections become active only after you have:
    1.  Completed "Asyndeton / Connecting Word."
    2.  Defined at least one verbal unit.
    3.  Assigned **more than one token** to at least one verbal unit.

*   **Syntax Graph Visualization:**
    *   This section (collapsible via `[–]` / `[+]`) displays a directed graph representing the relationships defined in the "Define Token Relations" table below it.
    *   Use the "Graph Orientation:" dropdown to choose between "Top to bottom" (Mermaid `BT`) or "Left to right" (Mermaid `RL`).
*   **Define Token Relations:**
    *   This table is initially populated with all lexical tokens from the selected sentence.
    *   For each token (identified by its "Reference" number, which is its sequence in the sentence):
        *   "Token": The text of the token (not editable).
        *   "Node 1 (ID)": Enter the "Reference" number of another token it relates to.
        *   "Node 1 Relation": Select the type of relation from the dropdown.
        *   "Node 2 (ID)" & "Node 2 Relation": Optionally define a second relationship for the token.
    *   **Implied Tokens:** Click "Add Implied Token Row" to create a row for a token that is grammatically implied but not explicit in the text. You can then link other tokens to this implied token's "Reference" number.
    *   Changes in this table will automatically update the "Syntax Graph Visualization" and the text decorations on tokens in the "Annotate Sentence" display and "Verbal Unit Structure" display.

**6. Download Annotations:**
*   Once you have completed the "Asyndeton / Connecting Word" step, the "Download Annotations for Current Sentence" button (at the very bottom) becomes active.
*   Click this button to save all your annotations for the currently selected sentence.
*   You will be prompted to enter a filename. The file will be saved with a `.cex` extension, containing your annotations in a delimited text format.

**General Workflow:**
The app is designed to be used sequentially. Completing earlier annotation steps often unlocks or enables later ones. If a section or control seems inactive, ensure you've completed the necessary preceding steps.

---